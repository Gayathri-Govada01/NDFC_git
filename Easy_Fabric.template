##template properties
name =Easy_Fabric;
description = Fabric for a VXLAN EVPN deployment with Nexus 9000 and 3000 switches.;
tags =Data Center VXLAN EVPN;
userDefined = true;
supportedPlatforms = All;
templateType = FABRIC;
templateSubType = NA;
contentType = PYTHON;
implements = ;
dependencies = ;
published = false;
imports = ;
##
##template variables

#    Copyright (c) 2018-2023 by Cisco Systems, Inc.
#    All rights reserved.
#General
@(IsMandatory=true, IsFabricName=true, DisplayName="Fabric Name", Description="Please provide the fabric name to create it (Max Size 64)")
string FABRIC_NAME{
  minLength = 1;
  maxLength = 128;
};

@(IsMandatory=true, Enum="vxlanIbgp,aimlVxlanIbgp", IsInternal=true, IsFabricInstance=true)
string unifiedNDFabricType {
defaultValue=vxlanIbgp;
};

@(IsMandatory=true, IsAsn=true, Description="1-4294967295 | 1-65535[.0-65535]<br/>It is a good practice to have a unique ASN for each Fabric.", DisplayName="BGP ASN")
string BGP_AS{
minLength=1;
maxLength=11;
regularExpr=^(((\+)?[1-9]{1}[0-9]{0,8}|(\+)?[1-3]{1}[0-9]{1,9}|(\+)?[4]{1}([0-1]{1}[0-9]{8}|[2]{1}([0-8]{1}[0-9]{7}|[9]{1}([0-3]{1}[0-9]{6}|[4]{1}([0-8]{1}[0-9]{5}|[9]{1}([0-5]{1}[0-9]{4}|[6]{1}([0-6]{1}[0-9]{3}|[7]{1}([0-1]{1}[0-9]{2}|[2]{1}([0-8]{1}[0-9]{1}|[9]{1}[0-5]{1})))))))))|([1-5]\d{4}|[1-9]\d{0,3}|6[0-4]\d{3}|65[0-4]\d{2}|655[0-2]\d|6553[0-5])(\.([1-5]\d{4}|[1-9]\d{0,3}|6[0-4]\d{3}|65[0-4]\d{2}|655[0-2]\d|6553[0-5]|0))?)$;
};

@(IsMandatory=false, IsInternal=true)
string BGP_AS_PREV;

@(IsMandatory=false, DisplayName="Enable IPv6 Underlay", Description="If not enabled, IPv4 underlay is used")
boolean UNDERLAY_IS_V6
{
defaultValue=false;
};

@(IsMandatory=false, IsInternal=true)
boolean UNDERLAY_IS_V6_PREV;

@(IsMandatory=false, IsShow="UNDERLAY_IS_V6==true", DisplayName="Enable IPv6 Link-Local Address",
Description="If not enabled, Spine-Leaf interfaces will use global IPv6 addresses")
boolean USE_LINK_LOCAL
{
defaultValue=true;
};

@(IsMandatory=true, Enum="p2p,unnumbered", IsShow="UNDERLAY_IS_V6!=true", DisplayName="Fabric Interface Numbering", Description="Numbered(Point-to-Point) or Unnumbered")
string FABRIC_INTERFACE_TYPE
{
defaultValue=p2p;
};

@(IsMandatory=true, IsShow="UNDERLAY_IS_V6!=true", Enum="30,31", Description="Mask for Underlay Subnet IP Range", DisplayName="Underlay Subnet IP Mask")
integer SUBNET_TARGET_MASK
{
min = 30;
max = 31;
defaultValue=30;
};

@(IsMandatory=true, IsShow="UNDERLAY_IS_V6==true && USE_LINK_LOCAL!=true", Enum="126,127", Description="Mask for Underlay Subnet IPv6 Range", DisplayName="Underlay Subnet IPv6 Mask")
integer V6_SUBNET_TARGET_MASK
{
min = 126;
max = 127;
defaultValue=126;
};

@(IsMandatory=true, Enum="ospf,is-is", DisplayName="Underlay Routing Protocol", Description="Used for Spine-Leaf Connectivity")
string LINK_STATE_ROUTING
{
defaultValue=ospf;
};

@(IsMandatory=true, Enum="2,4", Description="Number of spines acting as Route-Reflectors", DisplayName="Route-Reflectors")
integer RR_COUNT
{
defaultValue=2;
};
@(IsMandatory=true, IsAnycastGatewayMac=true, Description="Shared MAC address for all leafs (xxxx.xxxx.xxxx)", DisplayName="Anycast Gateway MAC")
macAddress ANYCAST_GW_MAC
{
defaultValue=2020.0000.00aa;
};

@(IsMandatory=false, NoConfigChg=true, DisplayName="Enable Performance Monitoring")
boolean PM_ENABLE
{
defaultValue=false;
};

@(IsMandatory=false, IsInternal=true)
boolean PM_ENABLE_PREV
{
defaultValue=false;
};

#Multicast Replication
@(IsMandatory=true, Enum="Multicast,Ingress", IsReplicationMode=true, Description="Replication Mode for BUM Traffic", DisplayName="Replication Mode", Section="Replication")
string REPLICATION_MODE
{
defaultValue=Multicast;
};

@(IsMandatory=true, IsMulticastGroupSubnet=true,
IsShow="REPLICATION_MODE==Multicast && UNDERLAY_IS_V6!=true", Description="Multicast pool prefix between 8 to 30. A multicast group IP<br/>from this pool is used for BUM traffic for each overlay network.", DisplayName="Multicast Group Subnet", Section="Replication")
ipV4AddressWithSubnet MULTICAST_GROUP_SUBNET
{
defaultValue=239.1.1.0/25;
};

@(IsMandatory=true, IsIPv6MulticastGroupSubnet=true,
IsShow="REPLICATION_MODE==Multicast && UNDERLAY_IS_V6==true", Description="IPv6 Multicast address with prefix 112 to 128", DisplayName="IPv6 Multicast Group Subnet", Section="Replication")
ipV6AddressWithSubnet IPv6_MULTICAST_GROUP_SUBNET
{
defaultValue=ff1e::/121;
};

@(IsMandatory=false, IsShow="REPLICATION_MODE==Multicast", Description="For Overlay IPv4 Multicast Support In VXLAN Fabrics", DisplayName="Enable IPv4 Tenant Routed Multicast (TRM)", Section="Replication")
boolean ENABLE_TRM
{
defaultValue=false;
};

@(IsMandatory=false, IsShow="REPLICATION_MODE==Multicast && MPLS_HANDOFF!=true", Description="For Overlay IPv6 Multicast Support In VXLAN Fabrics", DisplayName="Enable IPv6 Tenant Routed Multicast (TRMv6)", Section="Replication")
boolean ENABLE_TRMv6
{
defaultValue=false;
};

@(IsMandatory=true, IsMcastUnderlay=true,
IsShow="($$ENABLE_TRM$$=='true' && $$UNDERLAY_IS_V6$$!='true') || ($$ENABLE_TRMv6$$=='true' && $$UNDERLAY_IS_V6$$!='true')", DisplayName="Default MDT IPv4 Address for TRM VRFs", Description="Default Underlay Multicast group IPv4 address assigned for every overlay VRF", Section="Replication")
ipV4Address L3VNI_MCAST_GROUP
{
defaultValue=239.1.1.0;
};

@(IsMandatory=true, IsShow="($$ENABLE_TRM$$=='true' && $$UNDERLAY_IS_V6$$=='true') || ($$ENABLE_TRMv6$$=='true' && $$UNDERLAY_IS_V6$$=='true')", DisplayName="Default MDT IPv6 Address for TRM VRFs", Description="Default Underlay Multicast group IP6 address assigned for every overlay VRF", Section="Replication")
ipV6Address L3VNI_IPv6_MCAST_GROUP
{
defaultValue=ff1e::;
};

@(IsMandatory=true, IsShow="REPLICATION_MODE==Multicast", Enum="2,4", Description="Number of spines acting as Rendezvous-Point (RP)", DisplayName="Rendezvous-Points", Section="Replication")
integer RP_COUNT
{
defaultValue=2;
};

@(IsMandatory=true, IsShow="REPLICATION_MODE==Multicast", Enum="asm,bidir", Description="Multicast RP Mode. For IPv6 underlay, please use asm only", DisplayName="RP Mode", Section="Replication")
string RP_MODE
{
defaultValue=asm;
};

@(IsMandatory=true, IsShow="REPLICATION_MODE==Multicast", Description="(Min:0, Max:1023)", DisplayName="Underlay RP Loopback Id", Section="Replication")
integer RP_LB_ID{
min=0;
max=1023;
defaultValue=254;
};

@(IsMandatory=true, IsShow="REPLICATION_MODE==Multicast && RP_MODE==bidir && UNDERLAY_IS_V6!=true", Description="Used for Bidir-PIM Phantom RP <br/>(Min:0, Max:1023)", DisplayName="Underlay Primary <br/>RP Loopback Id", Section="Replication")
integer PHANTOM_RP_LB_ID1{
min=0;
max=1023;
defaultValue=2;
};

@(IsMandatory=true, IsShow="REPLICATION_MODE==Multicast && RP_MODE==bidir && UNDERLAY_IS_V6!=true", Description="Used for Fallback Bidir-PIM Phantom RP <br/>(Min:0, Max:1023)", DisplayName="Underlay Backup <br/>RP Loopback Id", Section="Replication")
integer PHANTOM_RP_LB_ID2{
min=0;
max=1023;
defaultValue=3;
};

@(IsMandatory=true, IsShow="REPLICATION_MODE==Multicast && RP_MODE==bidir && RP_COUNT==4 && UNDERLAY_IS_V6!=true", Description="Used for second Fallback Bidir-PIM Phantom RP <br/>(Min:0, Max:1023)", DisplayName="Underlay Second Backup <br/>RP Loopback Id", Section="Replication")
integer PHANTOM_RP_LB_ID3{
min=0;
max=1023;
defaultValue=4;
};

@(IsMandatory=true, IsShow="REPLICATION_MODE==Multicast && RP_MODE==bidir && RP_COUNT==4 && UNDERLAY_IS_V6!=true", Description="Used for third Fallback Bidir-PIM Phantom RP <br/>(Min:0, Max:1023)", DisplayName="Underlay Third Backup <br/>RP Loopback Id", Section="Replication")
integer PHANTOM_RP_LB_ID4{
min=0;
max=1023;
defaultValue=5;
};

@(IsMandatory=false, IsShow="($$ENABLE_TRM$$=='true' || $$ENABLE_TRMv6$$=='true') && ($$UNDERLAY_IS_V6$$=='true' || $$ALLOW_L3VNI_NO_VLAN$$=='true')", Description="MVPN VRI ID for vPC (Min:1, Max:65535), applicable when TRM enabled with IPv6 underlay, or TRM enabled with IPv4 underlay while fabric allows L3VNI w/o VLAN option", DisplayName="MVPN VRI ID Range", Section="Replication")
integerRange MVPN_VRI_ID_RANGE;

@(IsMandatory=false, IsShow="MVPN_VRI_ID_RANGE!=null", Description="One time VRI ID re-allocation based on 'MVPN VRI ID Range'", DisplayName="Enable MVPN VRI ID Re-allocation", Section="Replication")
boolean ENABLE_VRI_ID_REALLOC
{
defaultValue=false;
};

#vPC
@(IsMandatory=true, Description="VLAN range for vPC Peer Link SVI (Min:2, Max:4094)", DisplayName="vPC Peer Link VLAN Range", Section="vPC")
integerRange VPC_PEER_LINK_VLAN
{
min=2;
max=4094;
defaultValue=3600;
};

@(IsMandatory=false, DisplayName="Make vPC Peer Link VLAN as Native VLAN", Section="vPC")
boolean ENABLE_VPC_PEER_LINK_NATIVE_VLAN
{
defaultValue=false;
};

@(IsMandatory=true, Enum="loopback,management", Description="Use vPC Peer Keep Alive with Loopback or Management", DisplayName="vPC Peer Keep Alive option", Section="vPC")
string VPC_PEER_KEEP_ALIVE_OPTION
{
defaultValue=management;
};

@(IsMandatory=true, Description="(Min:240, Max:3600)", DisplayName="vPC Auto Recovery Time <br/>(In Seconds)", Section="vPC")
integer VPC_AUTO_RECOVERY_TIME
{
min = 240;
max = 3600;
defaultValue=360;
};

@(IsMandatory=true, Description="(Min:1, Max:3600)", DisplayName="vPC Delay Restore Time <br/>(In Seconds)", Section="vPC")
integer VPC_DELAY_RESTORE
{
min = 1;
max = 3600;
defaultValue=150;
};

@(IsMandatory=false, Description="(Min:1, Max:4096)", DisplayName="vPC Peer Link Port Channel ID", Section="vPC")
integerRange VPC_PEER_LINK_PO
{
min=1;
max=4096;
defaultValue=500;
};

@(IsMandatory=false, Description="Enable IPv6 ND synchronization between vPC peers", DisplayName="vPC IPv6 ND Synchronize", Section="vPC")
boolean VPC_ENABLE_IPv6_ND_SYNC
{
defaultValue=true;
};

@(IsMandatory=false, Description="For Primary VTEP IP Advertisement As Next-Hop Of Prefix Routes", DisplayName="vPC advertise-pip", Section="vPC")
boolean ADVERTISE_PIP_BGP
{
defaultValue=false;
};

@(IsMandatory=false, IsShow="ADVERTISE_PIP_BGP!=true", Description="Enable advertise-pip on vPC borders and border gateways only. Applicable only when vPC advertise-pip is not enabled", DisplayName="vPC advertise-pip on Border only", Section="vPC")
boolean ADVERTISE_PIP_ON_BORDER
{
defaultValue=true;
};

@(IsMandatory=false, Description="(Not Recommended) ", DisplayName="Enable the same vPC Domain Id <br/>for all vPC Pairs", Section="vPC")
boolean ENABLE_FABRIC_VPC_DOMAIN_ID
{
defaultValue=false;
};

@(IsMandatory=false, IsInternal=true)
boolean ENABLE_FABRIC_VPC_DOMAIN_ID_PREV;

@(IsMandatory=true, IsShow="ENABLE_FABRIC_VPC_DOMAIN_ID==true", Description="vPC Domain Id to be used on all vPC pairs", DisplayName="vPC Domain Id", Section="vPC")
integer FABRIC_VPC_DOMAIN_ID
{
min = 1;
max = 1000;
defaultValue=1;
};

@(IsMandatory=false, DisplayName="Internal Fabric Wide vPC Domain Id", IsInternal=true)
integer FABRIC_VPC_DOMAIN_ID_PREV
{
min = 1;
max = 1000;
};

@(IsMandatory=false, IsShow="ENABLE_FABRIC_VPC_DOMAIN_ID!=true", Description="vPC Domain id range to use for new pairings", DisplayName="vPC Domain Id Range", Section="vPC")
integerRange VPC_DOMAIN_ID_RANGE
{
min=1;
max=1000;
defaultValue=1-1000;
};

@(IsMandatory=false, Description="Enable Layer-3 Peer-Router on all Leaf Devices", DisplayName="vPC Layer-3 Peer-Router Option", Section="vPC")
boolean VPC_LAYER3_PEER_ROUTER
{
defaultValue=true;
};

@(IsMandatory=false, IsShow="ENABLE_DEFAULT_QUEUING_POLICY!=true && ENABLE_AI_ML_QOS_POLICY!=true", Description="Qos on spines for guaranteed delivery of vPC Fabric Peering communication", DisplayName="Enable Qos for Fabric vPC-Peering", Section="vPC")
boolean FABRIC_VPC_QOS
{
defaultValue=false;
};

@(IsMandatory=true, IsShow="FABRIC_VPC_QOS==true", Description="Qos Policy name should be same on all spines", DisplayName="Qos Policy Name", Section="vPC")
string FABRIC_VPC_QOS_POLICY_NAME
{
minLength = 1;
maxLength = 40;
defaultValue=spine_qos_for_fabric_vpc_peering;
};

@(IsMandatory=false, NoConfigChg=true, Description="Use specific vPC/Port-channel ID range for leaf-tor pairings", DisplayName="Use Specific vPC/Port-Channel ID Range", Section="vPC")
boolean ENABLE_AGG_ACC_ID_RANGE
{
defaultValue=false;
};

@(IsMandatory="ENABLE_AGG_ACC_ID_RANGE==true", NoConfigChg=true, IsShow="ENABLE_AGG_ACC_ID_RANGE==true", Description="Specify one vPC/Port-Channel ID range, this range is used for auto-allocating vPC/Port-Channel IDs for leaf-tor pairings", DisplayName="vPC/Port-Channel ID Range", Section="vPC")
integerRange AGG_ACC_VPC_PO_ID_RANGE
{
min=1;
max=4096;
defaultValue=1-499;
};

#Protocols

@(IsMandatory=true, Description="(Min:0, Max:1023)", DisplayName="Underlay Routing Loopback Id", Section="Protocols")
integer BGP_LB_ID{
min=0;
max=1023;
defaultValue=0;
};

@(IsMandatory=true, Description="(Min:0, Max:1023)", DisplayName="Underlay VTEP Loopback Id", Section="Protocols")
integer NVE_LB_ID{
min=0;
max=1023;
defaultValue=1;
};

@(IsMandatory=true, IsShow="UNDERLAY_IS_V6==true", Description="Used for vPC Peering in VXLANv6 Fabrics (Min:0, Max:1023)", DisplayName="Underlay Anycast Loopback Id", Section="Protocols")
integer ANYCAST_LB_ID{
min=0;
max=1023;
defaultValue=10;
};

@(IsMandatory=true, DisplayName="Underlay Routing Protocol Tag", Description="Underlay Routing Process Tag", Section="Protocols")
string LINK_STATE_ROUTING_TAG
{
minLength = 1;
maxLength = 20;
defaultValue=UNDERLAY;
};

@(IsMandatory=false, IsInternal=true)
string LINK_STATE_ROUTING_TAG_PREV;

@(IsMandatory=true, IsShow="LINK_STATE_ROUTING==ospf", DisplayName="OSPF Area Id", Description="OSPF Area Id in IP address format", Section="Protocols")
string OSPF_AREA_ID
{
minLength = 1;
maxLength = 15;
defaultValue=0.0.0.0;
};

@(IsMandatory=false, IsShow="LINK_STATE_ROUTING==ospf && UNDERLAY_IS_V6!=true", DisplayName="Enable OSPF Authentication", Section="Protocols")
boolean OSPF_AUTH_ENABLE{
defaultValue=false;
};

@(IsMandatory=true, IsShow="LINK_STATE_ROUTING==ospf && OSPF_AUTH_ENABLE==true", DisplayName="OSPF Authentication Key ID", Description="(Min:0, Max:255)", Section="Protocols")
integer OSPF_AUTH_KEY_ID
{
min = 0;
max = 255;
defaultValue = 127;
};

@(IsMandatory=true, IsShow="LINK_STATE_ROUTING==ospf && OSPF_AUTH_ENABLE==true", DisplayName="OSPF Authentication Key", Description="3DES Encrypted", Section="Protocols")
string OSPF_AUTH_KEY
{
minLength = 1;
maxLength = 256;
};

@(IsMandatory=true, IsShow="LINK_STATE_ROUTING==is-is", Enum="level-1,level-2", DisplayName="IS-IS Level", Description="Supported IS types: level-1, level-2", Section="Protocols")
string ISIS_LEVEL
{
defaultValue=level-2;
};

@(IsMandatory=false, IsShow="LINK_STATE_ROUTING==is-is", DisplayName="IS-IS NET Area Number", Description="NET in form of XX.<4-hex-digit Custom Area Number>.XXXX.XXXX.XXXX.00, default Area Number is 0001. If area number in existing NETs matches the previous area number set in fabric settings and is different from the current area number, these NETs will be updated by Recalculate and Deploy.", Section="Protocols")
string ISIS_AREA_NUM
{
regularExpr=^[a-fA-F0-9]{4}$;
defaultValue=0001;
};

@(IsMandatory=false, ReadOnly=true, IsInternal=true, IsShow="LINK_STATE_ROUTING==is-is", DisplayName="Previous IS-IS NET Area Number", Description="Area Number last used for generating IS-IS NET", Section="Protocols")
string ISIS_AREA_NUM_PREV;

@(IsMandatory=false, IsShow="LINK_STATE_ROUTING==is-is", DisplayName="Enable IS-IS Network Point-to-Point", Description="This will enable network point-to-point on fabric interfaces which are numbered", Section="Protocols")
boolean ISIS_P2P_ENABLE
{
defaultValue=true;
};

@(IsMandatory=false, IsShow="LINK_STATE_ROUTING==is-is && UNDERLAY_IS_V6!=true", DisplayName="Enable IS-IS Authentication", Section="Protocols")
boolean ISIS_AUTH_ENABLE{
defaultValue=false;
};

@(IsMandatory=true, IsShow="LINK_STATE_ROUTING==is-is && ISIS_AUTH_ENABLE==true", DisplayName="IS-IS Authentication Keychain Name", Section="Protocols")
string ISIS_AUTH_KEYCHAIN_NAME
{
minLength = 1;
maxLength = 63;
};

@(IsMandatory=true, IsShow="LINK_STATE_ROUTING==is-is && ISIS_AUTH_ENABLE==true", DisplayName="IS-IS Authentication Key ID", Description="(Min:0, Max:65535)", Section="Protocols")
integer ISIS_AUTH_KEYCHAIN_KEY_ID
{
min = 0;
max = 65535;
defaultValue = 127;
};

@(IsMandatory=true, IsShow="LINK_STATE_ROUTING==is-is && ISIS_AUTH_ENABLE==true", DisplayName="IS-IS Authentication Key", Description="Cisco Type 7 Encrypted", Section="Protocols")
string ISIS_AUTH_KEY
{
minLength = 1;
maxLength = 255;
};

@(IsMandatory=false, IsShow="LINK_STATE_ROUTING==is-is", DisplayName="Set IS-IS Overload Bit", Description="When enabled, set the overload bit for an elapsed time after a reload", Section="Protocols")
boolean ISIS_OVERLOAD_ENABLE
{
defaultValue=true;
};

@(IsMandatory=true, IsShow="LINK_STATE_ROUTING==is-is && ISIS_OVERLOAD_ENABLE==true", DisplayName="IS-IS Overload Bit Elapsed Time", Description="Clear the overload bit after an elapsed time in seconds", Section="Protocols")
integer ISIS_OVERLOAD_ELAPSE_TIME
{
min = 5;
max = 86400;
defaultValue=60;
};

@(IsMandatory=false, IsShow="UNDERLAY_IS_V6!=true", DisplayName="Enable BGP Authentication", Section="Protocols")
boolean BGP_AUTH_ENABLE{
defaultValue=false;
};

@(IsMandatory=true, Enum="3,7", IsShow="BGP_AUTH_ENABLE==true", DisplayName="BGP Authentication Key <br/>Encryption Type", Description="BGP Key Encryption Type: 3 - 3DES, 7 - Cisco", Section="Protocols")
string BGP_AUTH_KEY_TYPE {
defaultValue=3;
};

@(IsMandatory=true, IsShow="BGP_AUTH_ENABLE==true", DisplayName="BGP Authentication Key", Description="Encrypted BGP Authentication Key based on type", Section="Protocols")
string BGP_AUTH_KEY
{
minLength = 1;
maxLength = 256;
};

@(IsMandatory=false, DisplayName="Generate BGP EVPN Neighbor Description", Description="Add description for iBGP EVPN neighbors", Section="Protocols")
boolean AUTO_BGP_NEIGHBOR_DESC{
defaultValue=true;
};

@(IsMandatory=false, IsShow="REPLICATION_MODE==Multicast && UNDERLAY_IS_V6!=true", DisplayName="Enable PIM Hello Authentication", Description="Valid for IPv4 Underlay only", Section="Protocols")
boolean PIM_HELLO_AUTH_ENABLE{
defaultValue=false;
};

@(IsMandatory=true, IsShow="PIM_HELLO_AUTH_ENABLE==true", DisplayName="PIM Hello Authentication Key", Description="3DES Encrypted", Section="Protocols")
string PIM_HELLO_AUTH_KEY
{
minLength = 1;
maxLength = 256;
};

@(IsMandatory=false, IsShow="UNDERLAY_IS_V6!=true", DisplayName="Enable BFD", Description="Valid for IPv4 Underlay only", Section="Protocols")
boolean BFD_ENABLE{
defaultValue=false;
};

@(IsMandatory=false, IsInternal=true)
boolean BFD_ENABLE_PREV;

@(IsMandatory=false, IsShow="UNDERLAY_IS_V6!=true && BFD_ENABLE==true", DisplayName="Enable BFD For iBGP", Section="Protocols")
boolean BFD_IBGP_ENABLE{
defaultValue=false;
};

@(IsMandatory=false, IsShow="UNDERLAY_IS_V6!=true && BFD_ENABLE==true && LINK_STATE_ROUTING==ospf", DisplayName="Enable BFD For OSPF", Section="Protocols")
boolean BFD_OSPF_ENABLE{
defaultValue=false;
};

@(IsMandatory=false, IsShow="UNDERLAY_IS_V6!=true && BFD_ENABLE==true && LINK_STATE_ROUTING==is-is", DisplayName="Enable BFD For ISIS", Section="Protocols")
boolean BFD_ISIS_ENABLE{
defaultValue=false;
};

@(IsMandatory=false, IsShow="UNDERLAY_IS_V6!=true && BFD_ENABLE==true && REPLICATION_MODE==Multicast", DisplayName="Enable BFD For PIM", Section="Protocols")
boolean BFD_PIM_ENABLE{
defaultValue=false;
};

@(IsMandatory=false, IsShow="UNDERLAY_IS_V6!=true && FABRIC_INTERFACE_TYPE==p2p && BFD_ENABLE==true", DisplayName="Enable BFD Authentication", Description="Valid for P2P Interfaces only", Section="Protocols")
boolean BFD_AUTH_ENABLE{
defaultValue=false;
};

@(IsMandatory=true, IsShow="UNDERLAY_IS_V6!=true && BFD_ENABLE==true && FABRIC_INTERFACE_TYPE==p2p && BFD_AUTH_ENABLE==true", DisplayName="BFD Authentication Key ID", Section="Protocols")
integer BFD_AUTH_KEY_ID
{
min = 1;
max = 255;
defaultValue = 100;
};

@(IsMandatory=true, IsShow="UNDERLAY_IS_V6!=true && BFD_ENABLE==true && FABRIC_INTERFACE_TYPE==p2p && BFD_AUTH_ENABLE==true", DisplayName="BFD Authentication Key", Description="Encrypted SHA1 secret value", Section="Protocols")
string BFD_AUTH_KEY
{
minLength = 1;
maxLength = 40;
};

@(IsMandatory=false, IsMultiLineString=true, DisplayName="iBGP Peer-Template Config", Description="Speficies the iBGP Peer-Template config used for RR and<br/>spines with border role. ", Warning="Speficies the config used for RR and<br/> spines with border or border gateway role. <br/> This field should begin with<br/>'  template peer' or '  template peer-session'. <br/> This must have 2 leading spaces. <br/>Note ! All configs should <br/>strictly match show run output, <br/>with respect to case and newlines. <br/>Any mismatches will yield <br/>unexpected diffs during deploy.", Section="Protocols")
string IBGP_PEER_TEMPLATE;

@(IsMandatory=false, IsMultiLineString=true, DisplayName="Leaf/Border/Border Gateway<br/>iBGP Peer-Template Config ", Description="Specifies the config used for leaf, border or<br/> border gateway.<br/>If this field is empty, the peer template defined in<br/>iBGP Peer-Template Config is used on all BGP enabled devices<br/>(RRs,leafs, border or border gateway roles.", Warning="Specifies the config used for leaf, border or<br/> border gateway.<br/>If this field is empty, the peer template defined in<br/>iBGP Peer-Template Config is used on all BGP<br/>enabled devices (RRs, leafs,<br/> border or border gateway roles).<br/>This field should begin with<br/>'  template peer' or '  template peer-session'.<br/> This must have 2 leading spaces. <br/>Note ! All configs should <br/>strictly match 'show run' output, <br/>with respect to case and newlines. <br/>Any mismatches will yield <br/>unexpected diffs during deploy.", Section="Protocols")
string IBGP_PEER_TEMPLATE_LEAF;

#Security Groups
@(IsMandatory=false, IsShow="ENABLE_PVLAN!=true", DisplayName="Enable Security Groups", Description="Security group can be enabled only with cli overlay mode", Section="Security")
boolean ENABLE_SGT
{
defaultValue=false;
};

@(IsMandatory=false, IsShow="ENABLE_PVLAN!=true", NoConfigChg=true, IsInternal=true)
boolean ENABLE_SGT_PREV
{
defaultValue=false;
};

@(IsMandatory="ENABLE_SGT==true", NoConfigChg=true, IsShow="ENABLE_SGT==true", DisplayName="Security Group Name Prefix", Description="Prefix to be used when a new Security Group is created (Min:1, Max:10 characters)", Section="Security")
string SGT_NAME_PREFIX
{
minLength = 1;
maxLength = 10;
defaultValue=SG_;
regularExpr=^[a-zA-Z0-9-_]*$;
};

@(IsMandatory="ENABLE_SGT==true", NoConfigChg=true, IsShow="ENABLE_SGT==true", DisplayName="Security Group Tag (SGT) ID Range", Description="Min:16, Max: 65535. Reserved Range: 0-15", Section="Security")
integerRange SGT_ID_RANGE
{
min=16;
max=65535;
defaultValue=10000-14000;
};

@(IsMandatory=false, IsShow="ENABLE_SGT==true", DisplayName="Security Groups Pre-provision", Description="Generate security groups configuration for non-enforced VRFs", Section="Security")
boolean SGT_PREPROVISION {
defaultValue=false;
};

@(IsMandatory=false, IsShow="ENABLE_SGT==true", NoConfigChg=true, IsInternal=true)
boolean SGT_PREPROVISION_PREV {
defaultValue=false;
};

@(IsMandatory=false, NoConfigChg=true, IsInternal=true)
enum SGT_PREPROV_RECALC_STATUS
{
validValues=start,empty,completed;
defaultValue=empty;
};

@(IsMandatory=false, NoConfigChg=true, IsInternal=true)
enum SGT_RECALC_STATUS
{
validValues=start,empty,completed;
defaultValue=empty;
};

@(IsMandatory=false, IsInternal=true)
enum SGT_OPER_STATUS
{
validValues=on,off;
defaultValue=off;
};
  
@(IsMandatory=false, DisplayName="Enable MACsec", Description="Enable MACsec in the fabric. MACsec fabric parameters are used for configuring MACsec on a fabric link if MACsec is enabled on the link.", Section="Security")
boolean ENABLE_MACSEC {
defaultValue=false;
};

@(IsMandatory=false, IsInternal=true, Section="Security")
boolean ENABLE_MACSEC_PREV {
defaultValue=false;
};

@(IsMandatory=true, IsShow="ENABLE_MACSEC==true", DisplayName="MACsec Cipher Suite", Description="Configure Cipher Suite", Section="Security")
enum MACSEC_CIPHER_SUITE {
validValues=GCM-AES-128,GCM-AES-256,GCM-AES-XPN-128,GCM-AES-XPN-256;
defaultValue=GCM-AES-XPN-256;
};

@(IsMandatory=true, IsShow="ENABLE_MACSEC==true", DisplayName="MACsec Primary Key String", Description="Cisco Type 7 Encrypted Octet String", Section="Security")
string MACSEC_KEY_STRING {
minLength = 1;
maxLength = 130;
regularExpr=^[a-fA-F0-9]+$;
};

@(IsMandatory=true, IsShow="ENABLE_MACSEC==true", DisplayName="MACsec Primary Cryptographic Algorithm", Description="AES_128_CMAC or AES_256_CMAC", Section="Security")
enum MACSEC_ALGORITHM {
validValues=AES_128_CMAC,AES_256_CMAC;
defaultValue=AES_128_CMAC;
};

@(IsMandatory=true, IsShow="ENABLE_MACSEC==true", DisplayName="MACsec Fallback Key String", Description="Cisco Type 7 Encrypted Octet String", Section="Security")
string MACSEC_FALLBACK_KEY_STRING {
minLength = 1;
maxLength = 130;
regularExpr=^[a-fA-F0-9]+$;
};

@(IsMandatory=true, IsShow="ENABLE_MACSEC==true", DisplayName="MACsec Fallback Cryptographic Algorithm", Description="AES_128_CMAC or AES_256_CMAC", Section="Security")
enum MACSEC_FALLBACK_ALGORITHM {
validValues=AES_128_CMAC,AES_256_CMAC;
defaultValue=AES_128_CMAC;
};

@(IsMandatory=false, DisplayName="Enable DCI MACsec", Description="Enable MACsec on DCI links. DCI MACsec fabric parameters are used for configuring MACsec on a DCI link if 'Use Link MACsec Setting' is disabled on the link.", Section="Security")
boolean ENABLE_DCI_MACSEC {
defaultValue=false;
};

@(IsMandatory=false, IsInternal=true, Section="Security")
boolean ENABLE_DCI_MACSEC_PREV {
defaultValue=false;
};

@(IsMandatory=false, IsShow="ENABLE_DCI_MACSEC==true", DisplayName="Enable QKD", Description="Enable DCI MACsec with QKD config", Section="Security")
boolean ENABLE_QKD {
defaultValue=false;
};

@(IsMandatory=true, IsShow="ENABLE_DCI_MACSEC==true", DisplayName="DCI MACsec Cipher Suite", Description="Configure Cipher Suite", Section="Security")
enum DCI_MACSEC_CIPHER_SUITE {
validValues=GCM-AES-128,GCM-AES-256,GCM-AES-XPN-128,GCM-AES-XPN-256;
defaultValue=GCM-AES-XPN-256;
};

@(IsMandatory=true, IsShow="ENABLE_DCI_MACSEC==true", DisplayName="DCI MACsec Primary Key String", Description="Cisco Type 7 Encrypted Octet String", Section="Security")
string DCI_MACSEC_KEY_STRING {
minLength = 1;
maxLength = 130;
regularExpr=^[a-fA-F0-9]+$;
};

@(IsMandatory=true, IsShow="ENABLE_DCI_MACSEC==true", DisplayName="DCI MACsec Primary Cryptographic Algorithm", Description="AES_128_CMAC or AES_256_CMAC", Section="Security")
enum DCI_MACSEC_ALGORITHM {
validValues=AES_128_CMAC,AES_256_CMAC;
defaultValue=AES_128_CMAC;
};

@(IsMandatory="ENABLE_DCI_MACSEC==true && ENABLE_QKD!=true", IsShow="ENABLE_DCI_MACSEC==true", DisplayName="DCI MACsec Fallback Key String", Description="Cisco Type 7 Encrypted Octet String. This parameter is used when DCI link has QKD disabled.", Section="Security")
string DCI_MACSEC_FALLBACK_KEY_STRING {
minLength = 1;
maxLength = 130;
regularExpr=^[a-fA-F0-9]+$;
};

@(IsMandatory="ENABLE_DCI_MACSEC==true && ENABLE_QKD!=true", IsShow="ENABLE_DCI_MACSEC==true", DisplayName="DCI MACsec Fallback Cryptographic Algorithm", Description="AES_128_CMAC or AES_256_CMAC. This parameter is used when DCI link has QKD disabled.", Section="Security")
enum DCI_MACSEC_FALLBACK_ALGORITHM {
validValues=AES_128_CMAC,AES_256_CMAC;
defaultValue=AES_128_CMAC;
};

@(IsMandatory=true, IsShow="ENABLE_QKD==true", DisplayName="QKD Profile Name", Description="Name of crypto profile (Max Size 63)", Section="Security")
string QKD_PROFILE_NAME {
minLength = 1;
maxLength = 63;
};

@(IsMandatory=false, IsInternal=true, Section="Security")
boolean QKD_PROFILE_NAME_PREV;

@(IsMandatory=true, IsShow="ENABLE_QKD==true", DisplayName="KME Server IP", Description="Key Management Entity server IPv4 address", Section="Security")
ipV4Address KME_SERVER_IP;

@(IsMandatory=true, IsShow="ENABLE_QKD==true", DisplayName="KME Server Port Number", Description="Key Management Entity server port number", Section="Security")
integer KME_SERVER_PORT {
min=0;
max=65535;
};

@(IsMandatory=true, IsShow="ENABLE_QKD==true", DisplayName="Trustpoint Label", Description="Tls authentication type trustpoint label (Max Size 64)", Section="Security")
string TRUSTPOINT_LABEL {
minLength = 1;
maxLength = 64;
};

@(IsMandatory=false, IsShow="ENABLE_QKD==true", DisplayName="Ignore Certificate", Description="Skip verification of incoming certificate", Section="Security")
boolean IGNORE_CERT {
defaultValue=false;
};

@(IsMandatory=true, IsShow="ENABLE_MACSEC==true || ENABLE_DCI_MACSEC==true", DisplayName="MACsec Status Report Timer", Description="MACsec Operational Status periodic report timer in minutes", Section="Security")
integer MACSEC_REPORT_TIMER {
min = 5;
max = 60;
defaultValue=5;
};

#Advanced
@(IsMandatory=true, IsVrfTemplate=true, Enum="%TEMPLATES.vrf", Description="Default Overlay VRF Template For Leafs", DisplayName="VRF Template", AlwaysSetDefault=true, Section="Advanced")
string default_vrf
{
defaultValue=Default_VRF_Universal;
};

@(IsMandatory=true, IsNetworkTemplate=true, Enum="%TEMPLATES.network", Description="Default Overlay Network Template For Leafs", DisplayName="Network Template", AlwaysSetDefault=true, Section="Advanced")
string default_network
{
defaultValue=Default_Network_Universal;
};

@(IsMandatory=true, IsVrfExtensionTemplate=true, Enum="%TEMPLATES.vrfExtension", Description="Default Overlay VRF Template For Borders", DisplayName="VRF Extension Template", AlwaysSetDefault=true, Section="Advanced")
string vrf_extension_template
{
defaultValue=Default_VRF_Extension_Universal;
};

@(IsMandatory=true, IsNetworkExtensionTemplate=true, Enum="%TEMPLATES.networkExtension", Description="Default Overlay Network Template For Borders", DisplayName="Network Extension Template", AlwaysSetDefault=true, Section="Advanced")
string network_extension_template
{
defaultValue=Default_Network_Extension_Universal;
};

@(IsMandatory=false, DisplayName="Overlay Mode", Description="VRF/Network configuration using config-profile or CLI", Section="Advanced")
enum OVERLAY_MODE
{
validValues=config-profile,cli;
defaultValue=cli;
};

@(IsMandatory=false, IsInternal=true)
enum OVERLAY_MODE_PREV
{
validValues=config-profile,cli;
};

@(IsMandatory=false, DisplayName="Allow L3VNI w/o VLAN", Description="Whether allows L3 VNI configuration without VLAN configuration", Section="Advanced")
boolean ALLOW_L3VNI_NO_VLAN
{
defaultValue=true;
};

@(IsMandatory=false, IsInternal=true)
boolean ALLOW_L3VNI_NO_VLAN_PREV;

@(IsMandatory=false, IsShow="ALLOW_L3VNI_NO_VLAN!=false", DisplayName="Enable L3VNI w/o VLAN", Description="L3 VNI configuration without VLAN configuration. This value is propagated on vrf creation as the default value of 'Enable L3VNI w/o VLAN' in vrf", Section="Advanced")
boolean ENABLE_L3VNI_NO_VLAN
{
defaultValue=false;
};

@(IsMandatory=false, IsShow="ENABLE_SGT!=true", DisplayName="Enable Private VLAN (PVLAN)", Description="Enable PVLAN on switches except spines and super spines", Section="Advanced")
boolean ENABLE_PVLAN {
defaultValue=false;
};

@(IsMandatory=false, IsInternal=true)
boolean ENABLE_PVLAN_PREV;

@(IsMandatory="ENABLE_PVLAN==true", IsShow="ENABLE_PVLAN==true", IsPvlanSecNetworkTemplate=true, IsPvlanSecNetworkExtTemplate=true, Enum="%TEMPLATES.pvlanSecNetwork", Description="Default PVLAN Secondary Network Template", DisplayName="PVLAN Secondary Network Template", AlwaysSetDefault=true, Section="Advanced")
string default_pvlan_sec_network
{
defaultValue=Pvlan_Secondary_Network;
};

@(IsMandatory=false, IsSiteId=true,AutoPopulate="BGP_AS", Description="For EVPN Multi-Site Support (Min:1, Max: 281474976710655). <br/>Defaults to Fabric ASN", DisplayName="Site Id", Section="Advanced")
string SITE_ID
{
minLength=1;
maxLength=15;
regularExpr=^(((\+)?[1-9]{1}[0-9]{0,13}|(\+)?[1]{1}[0-9]{1,14}|(\+)?[2]{1}([0-7]{1}[0-9]{13}|[8]{1}([0-0]{1}[0-9]{12}|[1]{1}([0-3]{1}[0-9]{11}|[4]{1}([0-6]{1}[0-9]{10}|[7]{1}([0-3]{1}[0-9]{9}|[4]{1}([0-8]{1}[0-9]{8}|[9]{1}([0-6]{1}[0-9]{7}|[7]{1}([0-5]{1}[0-9]{6}|[6]{1}([0-6]{1}[0-9]{5}|[7]{1}([0-0]{1}[0-9]{4}|[1]{1}([0]{0}[0-9]{3}|[0]{1}([0-5]{1}[0-9]{2}|[6]{1}([0-4]{1}[0-9]{1}|[5]{1}[0-5]{1}))))))))))))))|([1-5]\d{4}|[1-9]\d{0,3}|6[0-4]\d{3}|65[0-4]\d{2}|655[0-2]\d|6553[0-5])(\.([1-5]\d{4}|[1-9]\d{0,3}|6[0-4]\d{3}|65[0-4]\d{2}|655[0-2]\d|6553[0-5]|0))?)$;
};



@(IsMandatory=true, IsMTU=true, Description="(Min:576, Max:9216). Must be an even number", DisplayName="Intra Fabric Interface MTU", Section="Advanced")
integer FABRIC_MTU
{
min = 576;
max = 9216;
defaultValue=9216;
};

@(IsMandatory=false, IsInternal=true)
integer FABRIC_MTU_PREV
{
min = 576;
max = 9216;
defaultValue=9216;
};

@(IsMandatory=true, IsMTU=true, Description="(Min:1500, Max:9216). Must be an even number", DisplayName="Layer 2 Host Interface MTU", Section="Advanced")
integer L2_HOST_INTF_MTU
{
min = 1500;
max = 9216;
defaultValue=9216;
};

@(IsMandatory=false, IsInternal=true)
integer L2_HOST_INTF_MTU_PREV
{
min = 1500;
max = 9216;
defaultValue=9216;
};

@(IsMandatory=false, DisplayName="Unshut Host Interfaces by Default", Section="Advanced")
boolean HOST_INTF_ADMIN_STATE {
defaultValue=true;
};

@(IsMandatory=true, Enum="ps-redundant,combined,insrc-redundant", Description="Default Power Supply Mode For The Fabric", DisplayName="Power Supply Mode", Section="Advanced")
string POWER_REDUNDANCY_MODE
{
defaultValue=ps-redundant;
};

@(IsMandatory=true, Enum="dense,lenient,moderate,strict,manual", Description="Fabric Wide CoPP Policy. Customized CoPP policy should be <br/> provided when 'manual' is selected", DisplayName="CoPP Profile", Section="Advanced")
string COPP_POLICY
{
defaultValue=strict;
};

@(IsMandatory=false, Description="NVE Source Inteface HoldDown Time (Min:1, Max:1500) in seconds", DisplayName="VTEP HoldDown Time", Section="Advanced")
integer HD_TIME{
min = 1;
max = 1500;
defaultValue=180;
};

@(IsMandatory=false, DisplayName="Brownfield Overlay Network Name <br/>Format", Description="Generated network name should be < 64 characters", Section="Advanced")
string BROWNFIELD_NETWORK_NAME_FORMAT
{
minLength = 1;
maxLength = 80;
defaultValue=Auto_Net_VNI$$VNI$$_VLAN$$VLAN_ID$$;
};

@(IsMandatory=false, DisplayName="Skip Overlay Network Interface Attachments", Description="Enable to skip overlay network interface attachments for Brownfield and Host Port Resync cases", Section="Advanced")
boolean BROWNFIELD_SKIP_OVERLAY_NETWORK_ATTACHMENTS
{
defaultValue=false;
};

@(IsMandatory=false, DisplayName="Enable CDP for Bootstrapped Switch", Description="Enable CDP on management interface", Section="Advanced")
boolean CDP_ENABLE
{
defaultValue=false;
};

@(IsMandatory=false, DisplayName="Enable VXLAN OAM", Section="Advanced", Description="Enable the Next Generation (NG) OAM feature for all switches in the fabric to aid in trouble-shooting VXLAN EVPN fabrics")
boolean ENABLE_NGOAM
{
defaultValue=true;
};

@(IsMandatory=false, DisplayName="Enable Tenant DHCP", Section="Advanced")
boolean ENABLE_TENANT_DHCP
{
defaultValue=true;
};

@(IsMandatory=false, DisplayName="Enable NX-API", Description="Enable HTTPS NX-API", Section="Advanced")
boolean ENABLE_NXAPI
{
defaultValue=true;
};

@(IsMandatory=false, IsShow="ENABLE_NXAPI==true", DisplayName="NX-API HTTPS Port Number", Section="Advanced")
integer NXAPI_HTTPS_PORT
{
min = 1;
max = 65535;
defaultValue=443;
};

@(IsMandatory=false, IsShow="ENABLE_NXAPI==true", DisplayName="Enable HTTP NX-API", Section="Advanced")
boolean ENABLE_NXAPI_HTTP
{
defaultValue=true;
};

@(IsMandatory=false, IsShow="ENABLE_NXAPI_HTTP==true", DisplayName="NX-API HTTP Port Number", Section="Advanced")
integer NXAPI_HTTP_PORT
{
min = 1;
max = 65535;
defaultValue=80;
};

@(IsMandatory=false, DisplayName="Enable L4-L7 Services Re-direction", Description="Enable feature pbr, sla sender, epbr, or enable feature pbr, based on the L4-L7 Services use case", Section="Advanced")
boolean ENABLE_PBR {
defaultValue=false;
};

@(IsMandatory=false, DisplayName="Enable Strict Config Compliance", Section="Advanced", Description="Enable bi-directional compliance checks to flag additional configs in the running config that are not in the intent/expected config")
boolean STRICT_CC_MODE{
defaultValue=false;
};

@(IsMandatory=false, Description="Enable only, when IP Authorization is enabled in the AAA Server", DisplayName="Enable AAA IP Authorization", Section="Advanced")
boolean AAA_REMOTE_IP_ENABLED
{
defaultValue=false;
};

@(IsMandatory=false, DisplayName="Enable NDFC as Trap Host", Section="Advanced", Description="Configure NDFC as a receiver for SNMP traps")
boolean SNMP_SERVER_HOST_TRAP
{
defaultValue=true;
};

@(IsMandatory=false, DisplayName="Anycast Border Gateway advertise-pip", Section="Advanced", Description="To advertise Anycast Border Gateway PIP as VTEP. Effective on MSD fabric 'Recalculate Config'")
boolean ANYCAST_BGW_ADVERTISE_PIP
{
defaultValue=false;
};

@(IsMandatory=false, IsFreezeMode=true, DisplayName="Disable all deployments in this fabric", Section="Hidden")
boolean DEPLOYMENT_FREEZE
{
defaultValue=false;
};

@(IsMandatory=true,Enum="Enable,Disable", IsShow="AAA_REMOTE_IP_ENABLED!=true", Description="Enable to clean switch configuration without reload when PreserveConfig=no", DisplayName="Greenfield Cleanup Option", Section="Advanced")
string GRFIELD_DEBUG_FLAG
{
defaultValue=Disable;
};

@(IsMandatory=false, IsShow="UNDERLAY_IS_V6!=true", DisplayName="Enable Precision Time Protocol (PTP)", Section="Advanced")
boolean FEATURE_PTP {
defaultValue=false;
};

@(IsMandatory=true, IsShow="FEATURE_PTP==true", Description="(Min:0, Max:1023)", DisplayName="PTP Source Loopback Id", Section="Advanced")
integer PTP_LB_ID
{
min = 0;
max = 1023;
defaultValue=0;
};

@(IsMandatory=true, IsShow="FEATURE_PTP==true", Description="Multiple Independent PTP Clocking Subdomains <br/>on a Single Network (Min:0, Max:127)", DisplayName="PTP Domain Id", Section="Advanced")
integer PTP_DOMAIN_ID
{
min = 0;
max = 127;
defaultValue=0;
};

@(IsMandatory=false, IsShow="FEATURE_PTP==true", Description="(Min:2, Max:3967) SVI used for ptp source on ToRs", DisplayName="PTP Source VLAN Id", Section="Advanced")
integer PTP_VLAN_ID
{
min = 2;
max = 3967;
};

@(IsMandatory=false, IsShow="UNDERLAY_IS_V6!=true && ENABLE_TRMv6!=true", DisplayName="Enable MPLS Handoff", Section="Advanced")
boolean MPLS_HANDOFF
{
defaultValue=false;
};

@(IsMandatory=true, IsShow="MPLS_HANDOFF==true && UNDERLAY_IS_V6!=true", Description="Used for VXLAN to MPLS SR/LDP Handoff <br/>(Min:0, Max:1023)", DisplayName="Underlay MPLS Loopback Id", Section="Advanced")
integer MPLS_LB_ID{
min=0;
max=1023;
defaultValue=101;
};

@(IsMandatory=false, IsShow="MPLS_HANDOFF==true", DisplayName="IS-IS NET Area Number for MPLS Handoff", Description="NET in form of XX.<4-hex-digit Custom Area Number>.XXXX.XXXX.XXXX.00, default Area Number is 0001, used only if routing protocol on DCI MPLS link is is-is", Section="Advanced")
string MPLS_ISIS_AREA_NUM
{
regularExpr=^[a-fA-F0-9]{4}$;
defaultValue=0001;
};

@(IsMandatory=false, IsInternal=true)
string MPLS_ISIS_AREA_NUM_PREV;

@(IsMandatory=false, DisplayName="Enable TCAM Allocation", Description="TCAM commands are automatically generated for VxLAN and vPC Fabric Peering when Enabled", Section="Advanced")
boolean TCAM_ALLOCATION{
defaultValue=true;
};

@(IsMandatory=false, IsShow="FABRIC_VPC_QOS!=true && ENABLE_AI_ML_QOS_POLICY!=true", DisplayName="Enable Default Queuing Policies", Section="Advanced")
boolean ENABLE_DEFAULT_QUEUING_POLICY{
defaultValue=false;
};

@(IsMandatory=true, IsShow="ENABLE_DEFAULT_QUEUING_POLICY==true", Enum="%TEMPLATES.QoS_Cloud", AlwaysSetDefault=true, DisplayName="N9K Cloud Scale Platform <br/>Queuing Policy", Description="Queuing Policy for all 92xx, -EX, -FX, -FX2, -FX3, -GX <br/>series switches in the fabric", Section="Advanced")
string DEAFULT_QUEUING_POLICY_CLOUDSCALE
{
defaultValue=queuing_policy_default_8q_cloudscale;
};

@(IsMandatory=true, IsShow="ENABLE_DEFAULT_QUEUING_POLICY==true", Enum="%TEMPLATES.QoS_R_Series", AlwaysSetDefault=true, DisplayName="N9K R-Series Platform <br/>Queuing Policy", Description="Queuing Policy for all R-Series <br/>switches in the fabric", Section="Advanced")
string DEAFULT_QUEUING_POLICY_R_SERIES
{
defaultValue=queuing_policy_default_r_series;
};

@(IsMandatory=true, IsShow="ENABLE_DEFAULT_QUEUING_POLICY==true", Enum="%TEMPLATES.QoS_Other", AlwaysSetDefault=true, DisplayName="Other N9K Platform <br/>Queuing Policy", Description="Queuing Policy for all other <br/>switches in the fabric", Section="Advanced")
string DEAFULT_QUEUING_POLICY_OTHER
{
defaultValue=queuing_policy_default_other;
};

@(IsMandatory=false, IsShow="FABRIC_VPC_QOS!=true && ENABLE_DEFAULT_QUEUING_POLICY!=true", DisplayName="Enable AI/ML QoS and Queuing Policies", Section="Advanced", Description="Configures QoS and Queuing Policies specific to N9K Cloud Scale switch fabric for AI/ML network loads" )
boolean ENABLE_AI_ML_QOS_POLICY{
defaultValue=false;
};

@(IsMandatory=false, IsInternal=true)
boolean ENABLE_AI_ML_QOS_POLICY_FLAP
{
defaultValue=false;
};

@(IsMandatory=true, IsAiml=true, IsShow="ENABLE_AI_ML_QOS_POLICY==true", Enum="%TEMPLATES.QoS_AIML", AlwaysSetDefault=true, DisplayName="AI/ML <br/>QoS & Queuing Policy", Description="Queuing Policy <br/>based on predominant fabric link speed: 400G / 100G / 25G", Section="Advanced")
string AI_ML_QOS_POLICY
{
defaultValue=AI_Fabric_QOS_400G;
};

@(IsMandatory=false, IsShow="ENABLE_AI_ML_QOS_POLICY==true", DisplayName="Priority flow control watch-dog interval", Description="Acceptable values from 101 to 1000 (milliseconds).  Leave blank for system default (100ms).", Section="Advanced")
integer PFC_WATCH_INT {
min = 101;
max = 1000;
};

@(IsMandatory=false, IsInternal=true)
integer PFC_WATCH_INT_PREV {
min = 101;
max = 1000;
};

@(IsMandatory=false, DisplayName="Enable Real Time Interface Statistics Collection", Description="Valid for NX-OS only and External Non-ND Telemetry Receiver", Section="Advanced")
boolean ENABLE_RT_INTF_STATS
{
defaultValue=false;
};

@(IsMandatory="ENABLE_RT_INTF_STATS==true", IsShow="ENABLE_RT_INTF_STATS==true", DisplayName="Interface Statistics Load Interval", Description="Time in seconds<br/>(Min:5, Max:300)", Section="Advanced")
integer INTF_STAT_LOAD_INTERVAL{
min=5;
max=300;
defaultValue=10;
};

@(IsMandatory=false, Enum="rpvst+,mst,unmanaged", DisplayName="Spanning Tree Root Bridge Protocol", Description="Which protocol to use for configuring root bridge? rpvst+: Rapid Per-VLAN Spanning Tree, mst: Multiple Spanning Tree, unmanaged (default): STP Root not managed by NDFC", Section="Advanced")
string STP_ROOT_OPTION
{
defaultValue=unmanaged;
};

@(IsMandatory=true, IsShow="STP_ROOT_OPTION==rpvst+", DisplayName="Spanning Tree VLAN Range", Description="Vlan range, Example: 1,3-5,7,9-11, Default is 1-3967", Section="Advanced")
integerRange STP_VLAN_RANGE
{
min=1;
max=4092;
defaultValue=1-3967;
};

@(IsMandatory=true, IsShow="STP_ROOT_OPTION==mst", DisplayName="MST Instance Range", Description="MST instance range, Example: 0-3,5,7-9, Default is 0", Section="Advanced")
integerRange MST_INSTANCE_RANGE
{
min=0;
max=4094;
defaultValue=0;
};

@(IsMandatory=true, IsShow="STP_ROOT_OPTION==rpvst+ || STP_ROOT_OPTION==mst", DisplayName="Spanning Tree Bridge Priority", Description="Bridge priority for the spanning tree in increments of 4096", Section="Advanced")
enum STP_BRIDGE_PRIORITY
{
validValues=0,4096,8192,12288,16384,20480,24576,28672,32768,36864,40960,45056,49152,53248,57344,61440;
defaultValue=0;
};

@(IsMandatory=false, IsMultiLineString=true, DisplayName="Leaf Pre-Interfaces Freeform Config", Description="Additional CLIs, added before interface configurations, for all Leafs as captured from Show Running Configuration", Section="Freeform")
string preInterfaceConfigLeaf;

@(IsMandatory=false, IsMultiLineString=true, DisplayName="Spine Pre-Interfaces Freeform Config", Description="Additional CLIs, added before interface configurations, for all Spines as captured from Show Running Configuration", Section="Freeform")
string preInterfaceConfigSpine;

@(IsMandatory=false, IsMultiLineString=true, DisplayName="ToR Pre-Interfaces Freeform Config", Description="Additional CLIs, added before interface configurations, for all ToRs as captured from Show Running Configuration", Section="Freeform")
string preInterfaceConfigTor;

@(IsMandatory=false, IsMultiLineString=true, DisplayName="Leaf Post-Interfaces Freeform Config", Description="Additional CLIs, added after interface configurations, for all Leafs as captured from Show Running Configuration", Section="Freeform")
string EXTRA_CONF_LEAF;

@(IsMandatory=false, IsMultiLineString=true, DisplayName="Spine Post-Interfaces Freeform Config", Description="Additional CLIs, added after interface configurations, for all Spines as captured from Show Running Configuration", Section="Freeform")
string EXTRA_CONF_SPINE;

@(IsMandatory=false, IsMultiLineString=true, DisplayName="ToR Post-Interfaces Freeform Config", Description="Additional CLIs, added after interface configurations, for all ToRs as captured from Show Running Configuration", Section="Freeform")
string EXTRA_CONF_TOR;

@(IsMandatory=false, IsMultiLineString=true, DisplayName="Intra-fabric Links Additional Config", Description="Additional CLIs for all Intra-Fabric links", Section="Freeform")
string EXTRA_CONF_INTRA_LINKS;

#Resources
@(IsMandatory=false, Description="Checking this will disable Dynamic Underlay IP Address Allocations", DisplayName="Manual Underlay IP Address <br/>Allocation", Section="Resources")
boolean STATIC_UNDERLAY_IP_ALLOC
{
defaultValue=false;
};

@(IsMandatory=true, IsShow="UNDERLAY_IS_V6!=true && STATIC_UNDERLAY_IP_ALLOC!=true", Description="Typically Loopback0 IP Address Range", DisplayName="Underlay Routing Loopback IP <br/>Range", Section="Resources")
ipV4AddressWithSubnet LOOPBACK0_IP_RANGE
{
defaultValue=10.2.0.0/22;
};

@(IsMandatory=true, IsShow="UNDERLAY_IS_V6!=true && STATIC_UNDERLAY_IP_ALLOC!=true", Description="Typically Loopback1 IP Address Range", DisplayName="Underlay VTEP Loopback IP Range", Section="Resources")
ipV4AddressWithSubnet LOOPBACK1_IP_RANGE
{
defaultValue=10.3.0.0/22;
};

@(IsMandatory=true, IsShow="($$STATIC_UNDERLAY_IP_ALLOC$$!='true' && $$UNDERLAY_IS_V6$$!='true' && $$REPLICATION_MODE$$=='Multicast') || ($$STATIC_UNDERLAY_IP_ALLOC$$=='true' && $$UNDERLAY_IS_V6$$!='true' && $$REPLICATION_MODE$$=='Multicast' && $$RP_MODE$$=='bidir')", Description="Anycast or Phantom RP IP Address Range", DisplayName="Underlay RP Loopback IP Range", Section="Resources")
ipV4AddressWithSubnet ANYCAST_RP_IP_RANGE
{
defaultValue=10.254.254.0/24;
};

@(IsMandatory=true, IsShow="UNDERLAY_IS_V6!=true && STATIC_UNDERLAY_IP_ALLOC!=true", Description="Address range to assign Numbered and Peer Link SVI IPs", DisplayName="Underlay Subnet IP Range", Section="Resources")
ipV4AddressWithSubnet SUBNET_RANGE
{
defaultValue=10.4.0.0/16;
};

@(IsMandatory=true, IsShow="MPLS_HANDOFF==true && UNDERLAY_IS_V6!=true && STATIC_UNDERLAY_IP_ALLOC!=true", Description="Used for VXLAN to MPLS SR/LDP Handoff", DisplayName="Underlay MPLS Loopback IP Range", Section="Resources")
ipV4AddressWithSubnet MPLS_LOOPBACK_IP_RANGE
{
defaultValue=10.101.0.0/25;
};

@(IsMandatory=true, IsShow="UNDERLAY_IS_V6==true && STATIC_UNDERLAY_IP_ALLOC!=true", Description="Typically Loopback0 IPv6 Address Range", DisplayName="Underlay Routing Loopback IPv6 <br/>Range", Section="Resources")
ipV6AddressWithSubnet LOOPBACK0_IPV6_RANGE
{
defaultValue=fd00::a02:0/119;
};

@(IsMandatory=true, IsShow="UNDERLAY_IS_V6==true && STATIC_UNDERLAY_IP_ALLOC!=true", Description="Typically Loopback1 and Anycast Loopback IPv6 Address Range", DisplayName="Underlay VTEP Loopback IPv6 <br/>Range", Section="Resources")
ipV6AddressWithSubnet LOOPBACK1_IPV6_RANGE
{
defaultValue=fd00::a03:0/118;
};

@(IsMandatory=true, IsShow="UNDERLAY_IS_V6==true && STATIC_UNDERLAY_IP_ALLOC!=true && USE_LINK_LOCAL!=true", Description="IPv6 Address range to assign Numbered and Peer Link SVI IPs", DisplayName="Underlay Subnet IPv6 Range", Section="Resources")
ipV6AddressWithSubnet V6_SUBNET_RANGE
{
defaultValue=fd00::a04:0/112;
};

@(IsMandatory=true, IsShow="STATIC_UNDERLAY_IP_ALLOC!=true && REPLICATION_MODE==Multicast && UNDERLAY_IS_V6==true", NoConfigChg=true, Description="Anycast RP IPv6 Address Range", DisplayName="Underlay RP Loopback IPv6 Range", Section="Resources")
ipV6AddressWithSubnet IPv6_ANYCAST_RP_IP_RANGE
{
defaultValue=fd00::254:254:0/118;
};

@(IsMandatory=true, IsShow="UNDERLAY_IS_V6==true && STATIC_UNDERLAY_IP_ALLOC!=true", DisplayName="BGP Router ID Range for IPv6 Underlay", Description="IPv4 Address Range for BGP Router Id", Section="Resources")
ipV4AddressWithSubnet ROUTER_ID_RANGE
{
defaultValue=10.2.0.0/23;
};

@(IsMandatory=true, IsL2VniRange=true, Description="Overlay Network Identifier Range (Min:1, Max:16777214)", DisplayName="Layer 2 VXLAN VNI Range", Section="Resources")
integerRange L2_SEGMENT_ID_RANGE
{
min=1;
max=16777214;
defaultValue=30000-49000;
};

@(IsMandatory=true, IsL3VniRange=true, Description="Overlay VRF Identifier Range (Min:1, Max:16777214)", DisplayName="Layer 3 VXLAN VNI Range", Section="Resources")
integerRange L3_PARTITION_ID_RANGE
{
min=1;
max=16777214;
defaultValue=50000-59000;
};

@(IsMandatory=true, IsNetworkVlanRange=true, Description="Per Switch Overlay Network VLAN Range (Min:2, Max:4094)", DisplayName="Network VLAN Range", Section="Resources")
integerRange NETWORK_VLAN_RANGE
{
min=2;
max=4094;
defaultValue=2300-2999;
};

@(IsMandatory=true, IsVrfVlanRange=true, Description="Per Switch Overlay VRF VLAN Range (Min:2, Max:4094)", DisplayName="VRF VLAN Range", Section="Resources")
integerRange VRF_VLAN_RANGE
{
min=2;
max=4094;
defaultValue=2000-2299;
};

@(IsMandatory=true, IsDot1qIdRange=true, Description="Per Border Dot1q Range For VRF Lite Connectivity (Min:2, Max:4093)", DisplayName="Subinterface Dot1q Range", Section="Resources")
integerRange SUBINTERFACE_RANGE
{
min=2;
max=4093;
defaultValue=2-511;
};

@(IsMandatory=true, Enum="Manual,Back2Back&ToExternal", Description="VRF Lite Inter-Fabric Connection Deployment Options. If 'Back2Back&ToExternal' is selected, VRF Lite IFCs are auto created between border devices of two Easy Fabrics, and between border devices in Easy Fabric and edge routers in External Fabric. The IP address is taken from the 'VRF Lite Subnet IP Range' pool.", DisplayName="VRF Lite Deployment", Section="Resources")
string VRF_LITE_AUTOCONFIG
{
defaultValue=Manual;
};

@(IsMandatory=false, IsShow="VRF_LITE_AUTOCONFIG!=Manual", DisplayName="Auto Deploy for Peer", Description="Whether to auto generate VRF LITE sub-interface and BGP peering configuration on managed neighbor devices. If set, auto created VRF Lite IFC links will have 'Auto Deploy for Peer' enabled.", Section="Resources")
boolean AUTO_SYMMETRIC_VRF_LITE
{
defaultValue=false;
};

@(IsMandatory=false, IsShow="VRF_LITE_AUTOCONFIG!=Manual && UNDERLAY_IS_V6!=true", DisplayName="Auto Deploy Default VRF", Description="For IPv4 underlay, whether to auto generate BGP peering in Default VRF for VRF Lite IFC auto deployment option. If set, will auto create VRF Lite Inter-Fabric links with 'Auto Deploy Default VRF' knob enabled", Section="Resources")
boolean AUTO_VRFLITE_IFC_DEFAULT_VRF
{
defaultValue=false;
};

@(IsMandatory=false, IsShow="AUTO_VRFLITE_IFC_DEFAULT_VRF==true", DisplayName="Auto Deploy Default VRF for Peer", Description="Whether to auto generate Default VRF interface and BGP peering configuration on managed neighbor devices. If set, auto created VRF Lite IFC links will have 'Auto Deploy Default VRF for Peer' enabled.", Section="Resources")
boolean AUTO_SYMMETRIC_DEFAULT_VRF
{
defaultValue=false;
};

@(IsMandatory="AUTO_VRFLITE_IFC_DEFAULT_VRF==true", IsShow="AUTO_VRFLITE_IFC_DEFAULT_VRF==true", DisplayName="Redistribute BGP Route-map Name", Description="Route Map used to redistribute BGP routes to IGP in default vrf in auto created VRF Lite IFC links", Section="Resources")
string DEFAULT_VRF_REDIS_BGP_RMAP
{
defaultValue=extcon-rmap-filter;
};

@(IsMandatory=true, Description="Address range to assign P2P Interfabric Connections", DisplayName="VRF Lite Subnet IP Range", Section="Resources")
ipV4AddressWithSubnet DCI_SUBNET_RANGE
{
defaultValue=10.33.0.0/16;
};

@(IsMandatory=true,  Description="(Min:8, Max:31)", DisplayName="VRF Lite Subnet Mask", Section="Resources")
integer DCI_SUBNET_TARGET_MASK
{
min = 8;
max = 31;
defaultValue=30;
};

@(IsMandatory=false, DisplayName="Auto Allocation of Unique IP on VRF Extension over VRF Lite IFC", Description="When enabled, IP prefix allocated to the VRF LITE IFC is not reused on VRF extension over VRF LITE IFC. Instead, unique IP Subnet is allocated for each VRF extension over VRF LITE IFC.", Section="Resources")
boolean AUTO_UNIQUE_VRF_LITE_IP_PREFIX
{
defaultValue=false;
};

@(IsMandatory=false, IsInternal=true, Section="Resources")
boolean AUTO_UNIQUE_VRF_LITE_IP_PREFIX_PREV
{
defaultValue=false;
};

@(IsMandatory=false, DisplayName="Per VRF Per VTEP Loopback IPv4 Auto-Provisioning", Description="Auto provision a loopback IPv4 on a VTEP on VRF attachment. <br/> Note: Enabling this option auto-provisions loopback on existing VRF attachments also when Edit, QuickAttach, or Multiattach actions are performed. <br/> Provisioned loopbacks cannot be deleted until VRFs are unattached.", Section="Resources")
boolean PER_VRF_LOOPBACK_AUTO_PROVISION
{
defaultValue=false;
};

@(IsMandatory=false, IsInternal=true, Section="Resources")
boolean PER_VRF_LOOPBACK_AUTO_PROVISION_PREV
{
defaultValue=false;
};

@(IsMandatory="PER_VRF_LOOPBACK_AUTO_PROVISION==true", IsShow="PER_VRF_LOOPBACK_AUTO_PROVISION==true", DisplayName="Per VRF Per VTEP IPv4 Pool for Loopbacks", Description="Prefix pool to assign IPv4 addresses to loopbacks on VTEPs on a per VRF basis", Section="Resources")
ipV4AddressWithSubnet PER_VRF_LOOPBACK_IP_RANGE
{
defaultValue=10.5.0.0/22;
};

@(IsMandatory=false, DisplayName="Per VRF Per VTEP Loopback IPv6 Auto-Provisioning", Description="Auto provision a loopback IPv6 on a VTEP on VRF attachment", Section="Resources")
boolean PER_VRF_LOOPBACK_AUTO_PROVISION_V6
{
defaultValue=false;
};

@(IsMandatory=false, IsInternal=true, Section="Hidden")
boolean PER_VRF_LOOPBACK_AUTO_PROVISION_V6_PREV
{
defaultValue=false;
};

@(IsMandatory="PER_VRF_LOOPBACK_AUTO_PROVISION_V6==true", IsShow="PER_VRF_LOOPBACK_AUTO_PROVISION_V6==true", DisplayName="Per VRF Per VTEP IPv6 Pool for Loopbacks", Description="Prefix pool to assign IPv6 addresses to loopbacks on VTEPs on a per VRF basis", Section="Resources")
ipV6AddressWithSubnet PER_VRF_LOOPBACK_IP_RANGE_V6
{
defaultValue=fd00::a05:0/112;
};

@(IsMandatory=false, DisplayName="Service Level Agreement (SLA) ID Range", Description="Per switch SLA ID Range (Min:1, Max: 2147483647)", Section="Resources")
integerRange SLA_ID_RANGE
{
min=1;
max=2147483647;
defaultValue=10000-19999;
};

@(IsMandatory=false, DisplayName="Tracked Object ID Range", Description="Per switch tracked object ID Range (Min:1, Max: 512)", Section="Resources")
integerRange OBJECT_TRACKING_NUMBER_RANGE
{
min=1;
max=512;
defaultValue=100-299;
};

@(IsMandatory=true, Description="Per Switch Overlay Service Network VLAN Range (Min:2, Max:4094)", DisplayName="Service Network VLAN Range", Section="Resources")
integerRange SERVICE_NETWORK_VLAN_RANGE
{
min=2;
max=4094;
defaultValue=3000-3199;
};

@(IsMandatory=true, Description="(Min:1, Max:65534)", DisplayName="Route Map Sequence Number Range", Section="Resources")
integerRange ROUTE_MAP_SEQUENCE_NUMBER_RANGE
{
min=1;
max=65534;
defaultValue=1-65534;
};

@(IsMandatory=false, DisplayName="Inband Management", IsShow="LINK_STATE_ROUTING==ospf && UNDERLAY_IS_V6!=true", Description="Manage switches with only Inband connectivity", Section="Manageability")
boolean INBAND_MGMT
{
defaultValue=false;
};

@(IsMandatory=false, IsInternal=true)
boolean INBAND_MGMT_PREV
{
defaultValue=false;
};

@(IsMandatory=false, Description="Comma separated list of IP Addresses(v4/v6)", DisplayName="DNS Server IPs", Section="Manageability")
ipAddressList DNS_SERVER_IP_LIST;

@(IsMandatory="DNS_SERVER_IP_LIST!=null", IsShow="DNS_SERVER_IP_LIST!=null", Description="One VRF for all DNS servers or a comma separated<br/>list of VRFs, one per DNS server", DisplayName="DNS Server VRFs", Section="Manageability")
string[] DNS_SERVER_VRF {
     
};

@(IsMandatory=false, Description="Comma separated list of IP Addresses(v4/v6)", DisplayName="NTP Server IPs", Section="Manageability")
ipAddressList NTP_SERVER_IP_LIST;

@(IsMandatory="NTP_SERVER_IP_LIST!=null", IsShow="NTP_SERVER_IP_LIST!=null", Description="One VRF for all NTP servers or a comma separated<br/>list of VRFs, one per NTP server", DisplayName="NTP Server VRFs", Section="Manageability")
string[] NTP_SERVER_VRF {
   
};

@(IsMandatory=false, Description="Comma separated list of IP Addresses(v4/v6)", DisplayName="Syslog Server IPs", Section="Manageability")
ipAddressList SYSLOG_SERVER_IP_LIST;

@(IsMandatory="SYSLOG_SERVER_IP_LIST!=null", IsShow="SYSLOG_SERVER_IP_LIST!=null", Description="Comma separated list of Syslog severity values,<br/>one per Syslog server (Min:0, Max:7)", DisplayName="Syslog Server Severity", Section="Manageability")
string[] SYSLOG_SEV {
    
};

@(IsMandatory="SYSLOG_SERVER_IP_LIST!=null", IsShow="SYSLOG_SERVER_IP_LIST!=null", Description="One VRF for all Syslog servers or a comma separated<br/>list of VRFs, one per Syslog server", DisplayName="Syslog Server VRFs", Section="Manageability")
string[] SYSLOG_SERVER_VRF {
  
};

@(IsMandatory=false, IsMultiLineString=true, DisplayName="AAA Freeform Config", Description="AAA Configurations", Section="Manageability")
string AAA_SERVER_CONF;

@(IsMandatory=false, IsMultiLineString=true, DisplayName="Banner", Description="Message of the Day (motd) banner. Delimiter char (very first char is delimiter char) followed by message ending with delimiter", Section="Manageability")
string BANNER;

@(IsMandatory=false, NoConfigChg=true, IsDhcpFlag=true, Description="Automatic IP Assignment For POAP", DisplayName="Enable Bootstrap", Section="Bootstrap")
boolean BOOTSTRAP_ENABLE{
defaultValue=false;
};

@(IsMandatory=false, IsInternal=true, Section="Bootstrap")
boolean BOOTSTRAP_ENABLE_PREV
{
defaultValue=false;
};

@(IsMandatory=false, NoConfigChg=true, IsShow="BOOTSTRAP_ENABLE==true", Description="Automatic IP Assignment For POAP From Local DHCP Server", DisplayName="Enable Local DHCP Server", Section="Bootstrap")
boolean DHCP_ENABLE{
defaultValue=false;
};

@(IsMandatory=false, NoConfigChg=true, Enum="DHCPv4,DHCPv6", IsShow="DHCP_ENABLE==true && BOOTSTRAP_ENABLE==true", DisplayName="DHCP Version", Section="Bootstrap")
string DHCP_IPV6_ENABLE
{
defaultValue=DHCPv4;
};

@(IsMandatory=true, NoConfigChg=true, IsShow="DHCP_ENABLE==true && BOOTSTRAP_ENABLE==true", Description="Start Address For Switch POAP", DisplayName="DHCP Scope Start Address", Section="Bootstrap")
ipAddress DHCP_START;

@(IsMandatory=true, NoConfigChg=true, IsShow="DHCP_ENABLE==true && BOOTSTRAP_ENABLE==true", Description="End Address For Switch POAP", DisplayName="DHCP Scope End Address", Section="Bootstrap")
ipAddress DHCP_END;

@(IsMandatory=true, NoConfigChg=true, IsShow="DHCP_ENABLE==true && BOOTSTRAP_ENABLE==true", Description="Default Gateway For Management VRF On The Switch", DisplayName="Switch Mgmt Default Gateway", Section="Bootstrap")
ipAddress MGMT_GW;

@(IsMandatory=true, NoConfigChg=true, IsShow="DHCP_ENABLE==true && BOOTSTRAP_ENABLE==true && DHCP_IPV6_ENABLE==DHCPv4", Description="(Min:8, Max:30)", DisplayName="Switch Mgmt IP Subnet Prefix", Section="Bootstrap")
integer MGMT_PREFIX
{
min = 8;
max = 30;
defaultValue=24;
};

@(IsMandatory=false, NoConfigChg=true, IsShow="DHCP_ENABLE==true && BOOTSTRAP_ENABLE==true && DHCP_IPV6_ENABLE==DHCPv6", Description="(Min:64, Max:126)", DisplayName="Switch Mgmt IPv6 Subnet Prefix", Section="Bootstrap")
integer MGMT_V6PREFIX
{
min = 64;
max = 126;
defaultValue=64;
};

@(IsMandatory=false, NoConfigChg=true, IsShow="DHCP_ENABLE==true && BOOTSTRAP_ENABLE==true", IsMultiLineString=true, DisplayName="DHCPv4 Multi Subnet Scope",  Description="lines with # prefix are ignored here", Warning="Enter One Subnet Scope per line. <br/> Start_IP, End_IP, Gateway, Prefix <br/> e.g. <br>10.6.0.2, 10.6.0.9, 10.6.0.1, 24 <br>10.7.0.2, 10.7.0.9, 10.7.0.1, 24", Section="Bootstrap")
string BOOTSTRAP_MULTISUBNET
{
defaultValue=#Scope_Start_IP, Scope_End_IP, Scope_Default_Gateway, Scope_Subnet_Prefix;
};

@(IsMandatory="BOOTSTRAP_ENABLE==true && INBAND_MGMT==true", IsShow="BOOTSTRAP_ENABLE==true && INBAND_MGMT==true", DisplayName="Seed Switch Fabric Interfaces", Description="Core-facing Interface list on Seed Switch (e.g. e1/1-30,e1/32)", Section="Bootstrap")
interfaceRange SEED_SWITCH_CORE_INTERFACES;

@(IsMandatory="BOOTSTRAP_ENABLE==true && INBAND_MGMT==true", IsShow="BOOTSTRAP_ENABLE==true && INBAND_MGMT==true", DisplayName="Spine Switch Fabric Interfaces", Description="Core-facing Interface list on all Spines (e.g. e1/1-30,e1/32)", Section="Bootstrap")
interfaceRange SPINE_SWITCH_CORE_INTERFACES;

@(IsMandatory=true, IsShow="BOOTSTRAP_ENABLE==true && INBAND_MGMT==true && DHCP_ENABLE!=true", Description="Comma separated list of IPv4 Addresses (Max 3)", DisplayName="External DHCP Server IP Addresses", Section="Bootstrap")
ipAddressList INBAND_DHCP_SERVERS;

@(IsMandatory=true, IsShow="BOOTSTRAP_ENABLE==true && INBAND_MGMT==true && DHCP_ENABLE==true && FABRIC_INTERFACE_TYPE==unnumbered", DisplayName="Bootstrap Seed Switch Loopback Interface ID", Section="Bootstrap")
integer UNNUM_BOOTSTRAP_LB_ID{
min=0;
max=1023;
defaultValue=253;
};

@(IsMandatory=true, IsShow="BOOTSTRAP_ENABLE==true && INBAND_MGMT==true && DHCP_ENABLE==true && FABRIC_INTERFACE_TYPE==unnumbered", Description="Must be a subset of IGP/BGP Loopback Prefix Pool", DisplayName="Switch Loopback DHCP Scope <br/> Start Address", Section="Bootstrap")
ipAddress UNNUM_DHCP_START;

@(IsMandatory=true, IsShow="BOOTSTRAP_ENABLE==true && INBAND_MGMT==true && DHCP_ENABLE==true && FABRIC_INTERFACE_TYPE==unnumbered", Description="Must be a subset of IGP/BGP Loopback Prefix Pool", DisplayName="Switch Loopback DHCP Scope <br/> End Address", Section="Bootstrap")
ipAddress UNNUM_DHCP_END;

@(IsMandatory=false, NoConfigChg=true, IsShow="BOOTSTRAP_ENABLE==true", Description="Include AAA configs from Manageability tab during device bootup", DisplayName="Enable AAA Config", Section="Bootstrap")
boolean ENABLE_AAA{
defaultValue = false;
};

@(IsMandatory=false, IsShow="BOOTSTRAP_ENABLE==true", IsMultiLineString=true, DisplayName="Bootstrap Freeform Config", Description="Additional CLIs required during device bootup/login e.g. AAA/Radius", Section="Bootstrap")
string BOOTSTRAP_CONF;

#Configuration Backup settings
@(IsMandatory=false, NoConfigChg=true, Description="Backup hourly only if there is any config deployment since last backup", DisplayName="Hourly Fabric Backup", Section="Configuration Backup")
boolean enableRealTimeBackup;
@(IsMandatory=false, NoConfigChg=true, Description="Backup at the specified time", DisplayName="Scheduled Fabric Backup", Section="Configuration Backup")
boolean enableScheduledBackup;
@(IsMandatory=true, NoConfigChg=true, IsShow="enableScheduledBackup==true", Description="Time (UTC) in 24hr format. (00:00 to 23:59)", DisplayName="Scheduled Time", Section="Configuration Backup")
string scheduledTime
{
    regularExpr=^([01]\d|2[0-3]):([0-5]\d)$;

};

# netflow is not supported for VXLANv6
@(IsMandatory=false, IsShow="UNDERLAY_IS_V6!=true", Description="Enable Netflow on VTEPs", DisplayName="Enable Netflow", Section="Flow Monitor", Container="netflowSettings")
boolean ENABLE_NETFLOW
{
defaultValue=false;
};

@(IsMandatory=false, IsInternal=true)
boolean ENABLE_NETFLOW_PREV;

@(IsMandatory=true, IsShow="ENABLE_NETFLOW==true", Description="One or Multiple Netflow Exporters", DisplayName="Netflow Exporter", Section="Flow Monitor", Container="netflowSettings")
struct ITEM {
  @(IsMandatory=true, DisplayName="Exporter Name")
  string EXPORTER_NAME;
  @(IsMandatory=true, DisplayName="IP")
  ipV4Address IP;
  @(IsMandatory=false, DisplayName="VRF")
  string VRF;
  @(IsMandatory=true, DisplayName="Source Interface")
  interface SRC_IF_NAME;
  @(IsMandatory=true, DisplayName="UDP Port")
  integer UDP_PORT {
    min = 1;
    max = 65535;
  };
} NETFLOW_EXPORTER_LIST[];

@(IsMandatory=true, IsShow="ENABLE_NETFLOW==true", Description="One or Multiple Netflow Records", DisplayName="Netflow Record", Section="Flow Monitor", Container="netflowSettings")
struct ITEM {
  @(IsMandatory=true, DisplayName="Record Name")
  string RECORD_NAME;
  @(IsMandatory=true, DisplayName="Record Template")
  #@(IsMandatory=true, Enum="%TEMPLATES.QoS_Cloud", DisplayName="Record Template")
  string RECORD_TEMPLATE
  {
    defaultValue=netflow_ipv4_record;
  };
  @(IsMandatory=false, DisplayName="Is Layer2 Record")
  boolean LAYER2_RECORD {
    defaultValue=false;
  };
} NETFLOW_RECORD_LIST[];

@(IsMandatory=true, IsShow="ENABLE_NETFLOW==true", Description="One or Multiple Netflow Monitors", DisplayName="Netflow Monitor", Section="Flow Monitor", Container="netflowSettings")
struct ITEM {
  @(IsMandatory=true, DisplayName="Monitor Name")
  string MONITOR_NAME;
  @(IsMandatory=true, DisplayName="Record Name")
  string RECORD_NAME;
  @(IsMandatory=true, DisplayName="Exporter1 Name")
  string EXPORTER1;
  @(IsMandatory=false, DisplayName="Exporter2 Name")
  string EXPORTER2;
} NETFLOW_MONITOR_LIST[];

@(IsMandatory=false, DisplayName="Enable Nexus Cloud", Description="Allow onboarding of this fabric to Nexus Cloud", Section="Nexus Cloud")
boolean ALLOW_NXC
{
defaultValue=true;
};

@(IsMandatory=false, IsInternal=true)
boolean ALLOW_NXC_PREV;

@(IsMandatory=false, IsShow="ALLOW_NXC==true", DisplayName="Overwrite Global NxCloud Settings", Description="If enabled, Fabric NxCloud Settings will be used", Section="Nexus Cloud")
boolean OVERWRITE_GLOBAL_NXC
{
defaultValue=false;
};

@(IsMandatory="OVERWRITE_GLOBAL_NXC==true", IsShow="OVERWRITE_GLOBAL_NXC==true", DisplayName="Intersight Destination VRF", Description="VRF to be used to reach Nexus Cloud, enter 'management' for management VRF and 'default' for default VRF", Section="Nexus Cloud")
string NXC_DEST_VRF
{
minLength = 1;
maxLength = 32;
defaultValue=management;
};

@(IsMandatory="OVERWRITE_GLOBAL_NXC==true && NXC_DEST_VRF!=management", IsShow="OVERWRITE_GLOBAL_NXC==true && NXC_DEST_VRF!=management", DisplayName="Intersight Source Interface", Description="Source interface for communication to Nexus Cloud, mandatory if Destination VRF is not management, supported interfaces: loopback, port-channel, vlan", Section="Nexus Cloud")
interface NXC_SRC_INTF;

@(IsMandatory=false, IsShow="OVERWRITE_GLOBAL_NXC==true", DisplayName="Intersight Proxy Server", Description="IPv4 or IPv6 address, or DNS name of the proxy server", Section="Nexus Cloud")
string NXC_PROXY_SERVER;

@(IsMandatory="NXC_PROXY_SERVER!=null", IsShow="NXC_PROXY_SERVER!=null", DisplayName="Proxy Server Port", Description="Proxy port number, default is 8080", Section="Nexus Cloud")
integer NXC_PROXY_PORT
{
min = 1;
max = 65535;
defaultValue = 8080;
};

@(IsMandatory=true, Description="vPC Delay Restore Time For vPC links in seconds (Min:1, Max:3600)", DisplayName="vPC Delay Restore Time", Section="Hidden")
integer VPC_DELAY_RESTORE_TIME
{
min = 1;
max = 3600;
defaultValue=60;
};

#Hidden
@(IsMandatory=true, IsFabricType=true, DisplayName="Fabric Type", ReadOnly=true, Section="Hidden")
string FABRIC_TYPE
{
defaultValue=Switch_Fabric;
};

@(IsMandatory=false, Section="Hidden")
string EXT_FABRIC_TYPE;

@(IsMandatory=false, Description="Enable Agnet (developmet purpose only)", DisplayName="Enable Agent", Section="Hidden")
boolean ENABLE_AGENT
{
defaultValue=false;
};

@(IsMandatory=false, Description="Interface to connect to Agent", DisplayName="Agent Interface", Enum="eth0,eth1", Section="Hidden")
string AGENT_INTF
{
defaultValue=eth0;
};

@(IsMandatory=true,Enum="Enable,Disable", Description="Allow First Super Spine Add or Last Super Spine Delete From Topology", DisplayName="Super Spine Force Add Del", Section="Hidden")
string SSPINE_ADD_DEL_DEBUG_FLAG
{
defaultValue=Disable;
};

@(IsMandatory=false, Enum="Enable,Disable", Description="Dont' use until you are aware about it", DisplayName="!!! Only for brf debugging purpose !!!", Section="Hidden")
string BRFIELD_DEBUG_FLAG
{
defaultValue=Disable;
};

@(IsMandatory=true, DisplayName="Active Migration", Section="Hidden")
boolean ACTIVE_MIGRATION
{
defaultValue=false;
};

@(IsMandatory=true, DisplayName="Template Family", Section="Hidden")
string FF
{
defaultValue=Easy_Fabric;
};

@(IsMandatory=false, IsInternal=true)
string MSO_SITE_ID;
@(IsMandatory=false, IsInternal=true)
string MSO_CONTROLER_ID;
@(IsMandatory=false, IsInternal=true)
string MSO_SITE_GROUP_NAME;
@(IsMandatory=false, IsInternal=true)
string PREMSO_PARENT_FABRIC;
@(IsMandatory=false, IsInternal=true)
string MSO_CONNECTIVITY_DEPLOYED;

@(IsMandatory=false, Section="Hidden")
ipV4AddressWithSubnet ANYCAST_RP_IP_RANGE_INTERNAL;

@(IsMandatory=false, Section="Hidden")
ipV6AddressWithSubnet IPv6_ANYCAST_RP_IP_RANGE_INTERNAL;

@(IsMandatory=false, NoConfigChg=true, IsInternal=true, Section="Bootstrap")
ipAddress DHCP_START_INTERNAL;

@(IsMandatory=false, NoConfigChg=true, IsInternal=true, Section="Bootstrap")
ipAddress DHCP_END_INTERNAL;

@(IsMandatory=false, NoConfigChg=true, IsInternal=true, Section="Bootstrap")
ipAddress MGMT_GW_INTERNAL;

@(IsMandatory=false, NoConfigChg=true, IsInternal=true, Section="Bootstrap")
integer MGMT_PREFIX_INTERNAL;

@(IsMandatory=false, NoConfigChg=true, IsInternal=true, Section="Bootstrap")
string BOOTSTRAP_MULTISUBNET_INTERNAL;

@(IsMandatory=false, NoConfigChg=true, IsInternal=true, Section="Bootstrap")
integer MGMT_V6PREFIX_INTERNAL;

@(IsMandatory=false, NoConfigChg=true, IsInternal=true, Section="Bootstrap")
string DHCP_IPV6_ENABLE_INTERNAL;

@(IsMandatory=false, NoConfigChg=true, IsInternal=true, Section="Bootstrap")
ipAddress UNNUM_DHCP_START_INTERNAL;

@(IsMandatory=false, NoConfigChg=true, IsInternal=true, Section="Bootstrap")
ipAddress UNNUM_DHCP_END_INTERNAL;

@(IsMandatory=true, IsInternal=true)
boolean ENABLE_EVPN
{
defaultValue=true;
};

@(IsMandatory=true, IsInternal=true)
boolean FEATURE_PTP_INTERNAL
{
defaultValue=false;
};

@(IsMandatory=false, IsInternal=true)
integer SSPINE_COUNT
{
defaultValue=0;
};

@(IsMandatory=false, IsInternal=true)
integer SPINE_COUNT
{
defaultValue=0;
};

#All policy templates starts from here.
@(IsMandatory=true, Enum="base_feature_leaf_upg", Description="Feature Configuration for Leaf", DisplayName="base_feature_leaf", Section="Policy Templates", IsInternal=true)
string abstract_feature_leaf {
defaultValue=base_feature_leaf_upg;
};

@(IsMandatory=true, Enum="base_feature_spine_upg", Description="Feature Configuration for Spine", DisplayName="base_feature_spine", Section="Policy Templates", IsInternal=true)
string abstract_feature_spine {
defaultValue=base_feature_spine_upg;
};

@(IsMandatory=true, Enum="base_dhcp", Description="DHCP Configuration", DisplayName="base_dhcp", Section="Policy Templates", IsInternal=true)
string abstract_dhcp
{
defaultValue=base_dhcp;
};

@(IsMandatory=true, Enum="base_multicast_11_1", Description="Multicast Configuration", DisplayName="base_multicast", Section="Policy Templates", IsInternal=true)
string abstract_multicast
{
defaultValue=base_multicast_11_1;
};

@(IsMandatory=true, Enum="anycast_rp", Description="Anycast RP Configuration", DisplayName="anycast_rp", Section="Policy Templates", IsInternal=true)
string abstract_anycast_rp
{
defaultValue=anycast_rp;
};

@(IsMandatory=true, Enum="int_fabric_loopback_11_1", Description="Primary Loopback Interface Configuration", DisplayName="loopback_interface", Section="Policy Templates", IsInternal=true)
string abstract_loopback_interface
{
defaultValue=int_fabric_loopback_11_1;
};

@(IsMandatory=true, Enum="base_isis_level2", Description="ISIS Network Configuration", DisplayName="base_isis_level2", Section="Policy Templates", IsInternal=true)
string abstract_isis
{
defaultValue=base_isis_level2;
};

@(IsMandatory=true, Enum="base_ospf", Description="OSPF Network Configuration", DisplayName="base_ospf", Section="Policy Templates", IsInternal=true)
string abstract_ospf
{
defaultValue=base_ospf;
};

@(IsMandatory=true, Enum="base_vpc_domain_11_1", Description="vPC Domain Configuration", DisplayName="base_vpc_domain", Section="Policy Templates", IsInternal=true)
string abstract_vpc_domain
{
defaultValue=base_vpc_domain_11_1;
};

@(IsMandatory=true, Enum="int_fabric_vlan_11_1", Description="VLAN Interface Configuration", DisplayName="vlan_interface", Section="Policy Templates", IsInternal=true)
string abstract_vlan_interface
{
defaultValue=int_fabric_vlan_11_1;
};

@(IsMandatory=true, Enum="isis_interface", Description="ISIS Interface Configuration", DisplayName="isis_interface", Section="Policy Templates", IsInternal=true)
string abstract_isis_interface
{
defaultValue=isis_interface;
};

@(IsMandatory=true, Enum="ospf_interface", Description="OSPF Interface Configuration", DisplayName="ospf_interface_11_1", Section="Policy Templates", IsInternal=true)
string abstract_ospf_interface
{
defaultValue=ospf_interface_11_1;
};

@(IsMandatory=true, Enum="pim_interface", Description="PIM Interface Configuration", DisplayName="pim_interface", Section="Policy Templates", IsInternal=true)
string abstract_pim_interface
{
defaultValue=pim_interface;
};

@(IsMandatory=true, Enum="route_map", Description="Route-Map Configuration", DisplayName="abstract_route_map", Section="Policy Templates", IsInternal=true)
string abstract_route_map
{
defaultValue=route_map;
};

@(IsMandatory=true, Enum="base_bgp", Description="BGP Configuration", DisplayName="base_bgp", Section="Policy Templates", IsInternal=true)
string abstract_bgp
{
defaultValue=base_bgp;
};

@(IsMandatory=true, Enum="evpn_bgp_rr", Description="BGP RR Configuration", DisplayName="evpn_bgp_rr", Section="Policy Templates", IsInternal=true)
string abstract_bgp_rr
{
defaultValue=evpn_bgp_rr;
};

@(IsMandatory=true, Enum= "evpn_bgp_rr_neighbor", Description="BGP Neighbor Configuration", DisplayName="evpn_bgp_rr_neighbor", Section="Policy Templates", IsInternal=true)
string abstract_bgp_neighbor
{
defaultValue=evpn_bgp_rr_neighbor;
};

@(IsMandatory=true, Enum= "extra_config_leaf", Description="Add Extra Configuration for Leaf", DisplayName="extra_config_leaf", Section="Policy Templates", IsInternal=true)
string abstract_extra_config_leaf
{
defaultValue=extra_config_leaf;
};

@(IsMandatory=true, Enum= "extra_config_spine", Description="Add Extra Configuration for Spine", DisplayName="extra_config_spine", Section="Policy Templates", IsInternal=true)
string abstract_extra_config_spine
{
defaultValue=extra_config_spine;
};

@(IsMandatory=true, Enum= "extra_config_tor", Description="Add Extra Configuration for ToR", DisplayName="extra_config_tor", Section="Policy Templates", IsInternal=true)
string abstract_extra_config_tor
{
defaultValue=extra_config_tor;
};

@(IsMandatory=true, Enum= "extra_config_bootstrap", Description="Add Extra Configuration for Bootstrap", DisplayName="extra_config_bootstrap", Section="Policy Templates", IsInternal=true)
string abstract_extra_config_bootstrap
{
defaultValue=extra_config_bootstrap_11_1;
};

@(IsMandatory=true, Enum="anycast_gateway", Description="Anycast Gateway MAC Configuration", DisplayName="anycast_gateway", Section="Policy Templates", IsInternal=true)
string temp_anycast_gateway
{
defaultValue=anycast_gateway;
};

@(IsMandatory=true, Enum="vpc_domain_mgmt", Description="vPC Keep-alive Configuration using Management VRF", DisplayName="vpc_domain_mgmt", Section="Policy Templates", IsInternal=true)
string temp_vpc_domain_mgmt
{
defaultValue=vpc_domain_mgmt;
};

@(IsMandatory=true, Enum="vpc_peer_link", Description="vPC Peer-Link Configuration", DisplayName="vpc_peer_link", Section="Policy Templates", IsInternal=true)
string temp_vpc_peer_link
{
defaultValue=int_vpc_peer_link_po;
};

@(IsMandatory=true, Enum="int_routed_host", Description="Routed Host Port Configuration", DisplayName="routed_host", Section="Policy Templates", IsInternal=true)
string abstract_routed_host
{
defaultValue=int_routed_host;
};

@(IsMandatory=true, Enum="int_trunk_host", Description="trunk Host Port Configuration", DisplayName="trunk_host", Section="Policy Templates", IsInternal=true)
string abstract_trunk_host
{
defaultValue=int_trunk_host;
};

@(IsMandatory=false, IsInternal=true)
string UPGRADE_FROM_VERSION;

@(IsMandatory=false, IsInternal=true)
string TOPDOWN_CONFIG_RM_TRACKING;

@(IsMandatory=false, IsInternal=true)
integer SITE_ID_POLICY_ID;

##
##template content

from com.cisco.dcbu.vinci.rest.services.jython import *
from com.cisco.dcbu.vinci.rest.services.jython import ResourceManagerWrapper as RM
from com.cisco.dcbu.vinci.rest.services.jython import PTIWrapper as PTI
from com.cisco.dcbu.vinci.rest.services.jython import InterfaceManagerWrapper as IM
from com.cisco.dcbu.vinci.rest.services.jython import BackupRestoreWrapper as BRW
from com.cisco.dcbu.vinci.rest.services.jython import ConfigDeployerWrapper as CDW
from com.cisco.dcbu.vinci.rest.services.jython import L4L7ServiceWrapper
from com.cisco.dcbu.vinci.rest.services.jython import InterfaceTypeEnum
from com.cisco.dcbu.vinci.rest.services.jython import ChangeMgmtWrapper
from com.cisco.dcbu.topdown.dao import CommonDAO
from com.cisco.dcbu.vinci.rest.services.jython import InterfabricConnectionWrapper
from com.cisco.dcbu.tor.service import ToRWrapper
from com.cisco.dcbu.jython.resource import Category
from com.cisco.dcbu.jython.resource import EntityType as ET
from com.cisco.dcbu.easy.util.jython.impl import FabricErrorLogger
from com.cisco.dcbu.vinci.rest.services.jython import TopDownOverlayWrapper as TD
from com.cisco.dcbu.commons.util import AppUtil
from com.cisco.dcbu.vinci.rest.services.jython import ReportWrapper

from topology import *
from utility import *

import sys, traceback
import re
import json
import copy

def isValidOspfAreaIdIPString(ipStr):
    ip = re.findall( r'''^[0-9]+(?:\.[0-9]+){3}$''', ipStr)
    isValid = True
    if len(ip) == 1:
        # convert string to ints
        ipInts = map(int, ip[0].split('.'))
        for ipInt in ipInts:
            if not ((ipInt >= 0) and (ipInt <= 255)):
                isValid = False
                break
    else:
        # not a valid IP address string
        isValid = False
    Wrapper.print("isValidOspfAreaIdIPString: FAB [%s]: OSPF Area Id IP String [%s]  isValid [%r]" % (FABRIC_NAME, ipStr, isValid))
    return isValid

def isValidBrownfieldNetworkFormat(netName):
    # name format is valid if the following rules are satisfied
    #   - must contain $$VNI$$
    #   - must not contain any other $$var$$
    #   - parts must not have any special chars besides '_' and '-' (Overlay network name restrictions)
    failureReason = None
    Wrapper.print("isValidBrownfieldNetworkFormat: netName [%s]" % (netName))

    if ("$$VNI$$" not in netName):
        failureReason = "Missing mandatory $$VNI$$ keyword"
        return failureReason

    specialCharChecker = re.compile(r'[^A-za-z0-9_-]')
    parts = re.split(r'(\$\$[^$]+\$\$)', netName)
    #Wrapper.print("isValidBrownfieldNetworkFormat: parts [%s]" % (parts))
    for part in parts:
        if not part or (part == ""):
            continue
        if ((part.startswith('$$') and (part.endswith('$$')))):
            #   - must not contain any other $$var$$
            if ((part != '$$VNI$$') and (part != '$$VLAN_ID$$')):
                failureReason = ("Invalid keyword in [%s]" % part)
                break
        else:
            #   - parts must not have any special chars besides '_' and '-' (Overlay network name restrictions)
            if specialCharChecker.search(part):
                failureReason = ("Invalid charater in [%s]" % part)
                break

    return failureReason

# returns True if change is allowed
def checkFabricMtuSettings(respObj):
    retCode = True

    Wrapper.print("checkFabricMtuSettings: FAB [%s]: Intra Fabric interface MTU [%s] -> [%s]" %
                (FABRIC_NAME, FABRIC_MTU_PREV, FABRIC_MTU))
    # ensure the MTU value is an even number
    if (int(FABRIC_MTU) % 2) != 0:
        # cannot allow this change
        respObj.addErrorReport("fabricInit", "Intra Fabric interface MTU [%s] must be an even number." % (FABRIC_MTU))
        respObj.setFailureRetCode()
        retCode = False

    Wrapper.print("checkFabricMtuSettings: FAB [%s]: Layer 2 Host interface MTU [%s] -> [%s]" %
                (FABRIC_NAME, L2_HOST_INTF_MTU_PREV, L2_HOST_INTF_MTU))
    # ensure the MTU value is an even number
    if (int(L2_HOST_INTF_MTU) % 2) != 0:
        # cannot allow this change
        respObj.addErrorReport("fabricInit", "Layer 2 Host interface MTU [%s] must be an even number." % (L2_HOST_INTF_MTU))
        respObj.setFailureRetCode()
        retCode = False

    return retCode

# returns True if change is allowed
def checkBgpAsChange(respObj):
    Wrapper.print("checkBgpAsChange: FAB [%s]: [%s] -> [%s]" % (FABRIC_NAME, BGP_AS_PREV, BGP_AS))
    if (BGP_AS_PREV != BGP_AS):
        try:
            getRespObj = FabricWrapper.getParentFabricName(FABRIC_NAME)
            if getRespObj.isRetCodeSuccess():
                # It is a member of MSD. Do not allow BGP AS change
                respObj.addErrorReport("fabricInit",
                    "BGP ASN cannot be changed from [%s] to [%s] on a Fabric Group member fabric." % (BGP_AS_PREV, BGP_AS))
                respObj.setFailureRetCode()
                return False
        except:
            Wrapper.print("exception, ignore if not member fabric")
            pass

        overlayPresent = Util.exe(Helper.isOverlayExist(FABRIC_NAME))
        if overlayPresent:
            # cannot allow this change
            respObj.addErrorReport("fabricInit",
                "BGP ASN cannot be changed from [%s] to [%s] with existing overlays." % (BGP_AS_PREV, BGP_AS))
            respObj.setFailureRetCode()
            return False

        # update the prev value
        FabricWrapper.update(FABRIC_NAME, "BGP_AS_PREV", BGP_AS)
    return True

# returns True if change is allowed
def checkUnderlayProtocolChange(respObj):
    Wrapper.print("checkUnderlayProtocolChange: FAB [%s]: LINK_STATE_ROUTING [%s]" % (FABRIC_NAME, LINK_STATE_ROUTING))

    topologyDataObj = TopologyData(Util.exe(TopologyWrapper.get(FABRIC_NAME)))
    devices = topologyDataObj.get(TopologyInfoType.SWITCHES)
    devices = filter(None, devices)
    if len(devices) == 0:
        return True

    for deviceSn in devices:
        if LINK_STATE_ROUTING == "is-is":
            ptiList = Util.exe(PTIWrapper.get(deviceSn, "SWITCH", "SWITCH", "UNDERLAY", "base_ospf"))
            ptiListV3 = Util.exe(PTIWrapper.get(deviceSn, "SWITCH", "SWITCH", "UNDERLAY", "base_ospfv3"))
            if ptiList or ptiListV3:
                respObj.addErrorReport("fabricInit",
                    "Cannot change fabric Underlay Routing Protocol to IS-IS with existing OSPF config")
                respObj.setFailureRetCode()
                return False
        elif LINK_STATE_ROUTING == "ospf":
            ptiList = Util.exe(PTIWrapper.get(deviceSn, "SWITCH", "SWITCH", "UNDERLAY", "base_isis_level2"))
            if ptiList:
                respObj.addErrorReport("fabricInit",
                    "Cannot change fabric Underlay Routing Protocol to OSPF with existing IS-IS config")
                respObj.setFailureRetCode()
                return False
    return True

# returns True if change is allowed
def checkLinkProtocolTagChange(respObj):
    Wrapper.print("checkLinkProtocolTagChange: FAB [%s]: [%s] -> [%s]" % (FABRIC_NAME, LINK_STATE_ROUTING_TAG_PREV, LINK_STATE_ROUTING_TAG))
    if (LINK_STATE_ROUTING_TAG_PREV != LINK_STATE_ROUTING_TAG):
        overlayPresent = Util.exe(Helper.isOverlayExist(FABRIC_NAME))
        if overlayPresent:
            # cannot allow this change
            respObj.addErrorReport("fabricInit",
                "Link-State Routing Protocol Tag cannot be changed from [%s] to [%s] with existing overlays." %
                (LINK_STATE_ROUTING_TAG_PREV, LINK_STATE_ROUTING_TAG))
            respObj.setFailureRetCode()
            return False

        # update the prev value
        FabricWrapper.update(FABRIC_NAME, "LINK_STATE_ROUTING_TAG_PREV", LINK_STATE_ROUTING_TAG)
    return True

# returns True if change is allowed
def checkOverlayModeChange(respObj):
    Wrapper.print("checkOverlayModeChange: FAB [%s]: [%s] -> [%s]" % (FABRIC_NAME, OVERLAY_MODE_PREV, OVERLAY_MODE))
    if (OVERLAY_MODE_PREV != "" and OVERLAY_MODE_PREV != OVERLAY_MODE):
        topologyDataObj = TopologyData(Util.exe(TopologyWrapper.get(FABRIC_NAME)))
        devices = topologyDataObj.get(TopologyInfoType.SWITCHES)
        devices = filter(None, devices)
        overlayConfigPresent = False
        for deviceSn in devices:
            if not CommonDAO.areOverlaysPresent(deviceSn):
                overlayConfigPresent = True
                break

        if overlayConfigPresent:
            # cannot allow this change
            respObj.addErrorReport("fabricInit",
                "Overlay Mode cannot be changed from [%s] to [%s] with overlay configurations "
                "already applied on switches." % (OVERLAY_MODE_PREV, OVERLAY_MODE))
            respObj.setFailureRetCode()
            return False

    # update the prev value
    FabricWrapper.update(FABRIC_NAME, "OVERLAY_MODE_PREV", OVERLAY_MODE)
    return True

def macSecSanityCheck(respObj):
    if ENABLE_MACSEC == "false":
        return True

    dictObj = {"MACSEC_KEY_STRING": MACSEC_KEY_STRING,
               "MACSEC_ALGORITHM": MACSEC_ALGORITHM,
               "MACSEC_FALLBACK_KEY_STRING": MACSEC_FALLBACK_KEY_STRING,
               "MACSEC_FALLBACK_ALGORITHM": MACSEC_FALLBACK_ALGORITHM,
               "FABRIC_NAME": FABRIC_NAME,
               "IS_DCI_MACSEC": "false",
               "DCI_LINK": ""}
    Util.processRespObj(respObj, PTI.executePyTemplateMethod("interface_utility", dictObj, "macSecSanityCheckExtn"))
    if respObj.isRetCodeFailure():
        return False
    else:
        return True

def DCImacSecSanityCheck(respObj):
    if ENABLE_DCI_MACSEC == "false":
        return True

    dictObj = {"MACSEC_KEY_STRING": DCI_MACSEC_KEY_STRING,
               "MACSEC_ALGORITHM": DCI_MACSEC_ALGORITHM,
               "MACSEC_FALLBACK_KEY_STRING": DCI_MACSEC_FALLBACK_KEY_STRING,
               "MACSEC_FALLBACK_ALGORITHM": DCI_MACSEC_FALLBACK_ALGORITHM,
               "FABRIC_NAME": FABRIC_NAME,
               "IS_DCI_MACSEC": "true",
               "DCI_LINK": ""}
    Util.processRespObj(respObj, PTI.executePyTemplateMethod("interface_utility", dictObj, "macSecSanityCheckExtn"))
    if respObj.isRetCodeFailure():
        return False
    else:
        return True

# returns True if fabric MACsec can be disabled in fabric settings
def disableMACsecAllowed(respObj, enableMacSecPrev):
    funcName = sys._getframe(0).f_code.co_name
    Wrapper.print("%s: FAB [%s]: ENABLE_MACSEC [%s] enableMacSecPrev [%s]" %
                  (funcName, FABRIC_NAME, ENABLE_MACSEC, enableMacSecPrev))

    if ENABLE_MACSEC == "true" or (ENABLE_MACSEC == "false" and enableMacSecPrev == "false"):
        return True

    topologyDataObj = TopologyData(Util.exe(TopologyWrapper.get(FABRIC_NAME)))
    devices = topologyDataObj.get(TopologyInfoType.SWITCHES)
    devices = filter(None, devices)
    if len(devices) == 0:
        return True

    foundFailure = False
    for deviceSn in devices:
        srchOpt = CtrlPolicySearch()
        srchOpt.setSerialNumber(deviceSn)
        if ENABLE_MACSEC == "false":
            srchOpt.setTemplateName("macsec_fallback_interface")
            ptiList = Util.exe(PTIWrapper.getPTIs(srchOpt))
            for pti in ptiList:
                if pti.isDeleted():
                    continue
                if pti.getNvPairs()["KEY_CHAIN_NAME"] == "MACsec_Key_Chain1":
                    respObj.addErrorReport(getFabErrEntity(funcName, deviceSn),
                        "Cannot disable fabric MACsec as MACsec is configured on some fabric interfaces", deviceSn)
                    foundFailure = True
                    break

    if foundFailure:
        respObj.setFailureRetCode()
        return False
    else:
        return True

# returns True if DCI MACsec can be disabled in fabric settings
def disableDCIMACsecAllowed(respObj, enableDCIMacSecPrev):
    funcName = sys._getframe(0).f_code.co_name
    Wrapper.print("%s: FAB [%s]: ENABLE_DCI_MACSEC [%s] ENABLE_QKD [%s] enableDCIMacSecPrev [%s]" %
                  (funcName, FABRIC_NAME, ENABLE_DCI_MACSEC, ENABLE_QKD, enableDCIMacSecPrev))

    dictObj = {"ENABLE_DCI_MACSEC": ENABLE_DCI_MACSEC,
               "ENABLE_DCI_MACSEC_PREV": enableDCIMacSecPrev,
               "ENABLE_QKD": ENABLE_QKD,
               "FABRIC_NAME": FABRIC_NAME}
    Util.processRespObj(respObj, PTI.executePyTemplateMethod("fabric_utility_11_1", dictObj, "disableDCIMACsecAllowedCheck"))
    if respObj.isRetCodeFailure():
        return False
    else:
        return True

# returns True if DCI QKD Profile Name can be changed in fabric settings
def changeDCIQKDAllowed(respObj, qkdProfileNamePrev):
    funcName = sys._getframe(0).f_code.co_name
    Wrapper.print("%s: FAB [%s]: ENABLE_DCI_MACSEC [%s] ENABLE_QKD [%s] QKD_PROFILE_NAME [%s] qkdProfileNamePrev [%s]" %
                  (funcName, FABRIC_NAME, ENABLE_DCI_MACSEC, ENABLE_QKD, QKD_PROFILE_NAME, qkdProfileNamePrev))

    dictObj = {"ENABLE_DCI_MACSEC": ENABLE_DCI_MACSEC,
               "ENABLE_QKD": ENABLE_QKD,
               "QKD_PROFILE_NAME": QKD_PROFILE_NAME,
               "QKD_PROFILE_NAME_PREV": qkdProfileNamePrev,
               "FABRIC_NAME": FABRIC_NAME}
    Util.processRespObj(respObj, PTI.executePyTemplateMethod("fabric_utility_11_1", dictObj, "changeDCIQKDAllowedCheck"))
    if respObj.isRetCodeFailure():
        return False
    else:
        return True

def checkFabricVpcDomainId(respObj):
    global ENABLE_FABRIC_VPC_DOMAIN_ID, ENABLE_FABRIC_VPC_DOMAIN_ID_PREV, FABRIC_VPC_DOMAIN_ID, FABRIC_VPC_DOMAIN_ID_PREV

    # check for any changes to the vpc domain id settings
    vpcDomainEnableSettingChanged = False
    if (ENABLE_FABRIC_VPC_DOMAIN_ID != ENABLE_FABRIC_VPC_DOMAIN_ID_PREV):
        vpcDomainEnableSettingChanged = True

    vpcDomainIdSettingChanged = False
    if ENABLE_FABRIC_VPC_DOMAIN_ID == "true":
        if FABRIC_VPC_DOMAIN_ID != FABRIC_VPC_DOMAIN_ID_PREV:
            vpcDomainIdSettingChanged = True
    Wrapper.print("checkFabricVpcDomainId: vpc domain Enable [%s] -> [%s] [%r], Domain id [%s] -> [%s] [%r]" % 
        (ENABLE_FABRIC_VPC_DOMAIN_ID_PREV, ENABLE_FABRIC_VPC_DOMAIN_ID, vpcDomainEnableSettingChanged,
            FABRIC_VPC_DOMAIN_ID_PREV, FABRIC_VPC_DOMAIN_ID, vpcDomainIdSettingChanged))

    if vpcDomainEnableSettingChanged or vpcDomainIdSettingChanged:
        # do not allow the change if there are existing VPC pairs
        topologyDataObj = TopologyData(Util.exe(TopologyWrapper.get(FABRIC_NAME)))

        devices = topologyDataObj.get(TopologyInfoType.SWITCHES)
        devices = filter(None, devices)
        for deviceSn in devices:
            isVPC = Util.exe(VpcWrapper.isVpc(FABRIC_NAME, deviceSn))
            if isVPC:
                if vpcDomainEnableSettingChanged:
                    errStr = ("Fabric wide vPC Domain ID Enable setting cannot be changed from [%s] to [%s] with existing vPC pairs." %
                        (ENABLE_FABRIC_VPC_DOMAIN_ID_PREV, ENABLE_FABRIC_VPC_DOMAIN_ID))
                else:
                    errStr = ("Fabric wide vPC Domain ID cannot be changed from [%s] to [%s] with existing vPC pairs." %
                        (FABRIC_VPC_DOMAIN_ID_PREV, FABRIC_VPC_DOMAIN_ID))

                respObj.addErrorReport("fabricInit",errStr)
                respObj.setFailureRetCode()
                return False

        # the vpc domain id is ok to change
        ENABLE_FABRIC_VPC_DOMAIN_ID_PREV = ENABLE_FABRIC_VPC_DOMAIN_ID
        Util.exe(FabricWrapper.update(FABRIC_NAME, "ENABLE_FABRIC_VPC_DOMAIN_ID_PREV", ENABLE_FABRIC_VPC_DOMAIN_ID_PREV))
        FABRIC_VPC_DOMAIN_ID_PREV = FABRIC_VPC_DOMAIN_ID
        Util.exe(FabricWrapper.update(FABRIC_NAME, "FABRIC_VPC_DOMAIN_ID_PREV", FABRIC_VPC_DOMAIN_ID_PREV))
    return True

def putSwitchIntoMgmtModeMigrMode(fabricName, devSerial):
    formattedName = getFormattedSwitchName(devSerial)
    Wrapper.print("=======ACTION: FAB [%s]. Put switch [%s] into mgmt mode migration mode" % (fabricName, formattedName))
    ptis = Util.exe(PTIWrapper.get(devSerial, "SWITCH", "SWITCH","", "switch_migration_state"))
    for pti in ptis:
        nvPairs = pti.getNvPairs()
        if nvPairs:
            Wrapper.print("putSwitchIntoOverlayMigrMode: Switch [%s] Migration [%s] NvPair = [%s]" % 
                                    (devSerial, formattedName, nvPairs))
            newNvPairs = copy.deepcopy(nvPairs)
            newNvPairs["OVERLAY"] = "true"
            Util.exe(PTIWrapper.createOrUpdate(devSerial, "SWITCH", "SWITCH", "", 10, "switch_migration_state", newNvPairs))
        break

def checkInbandMgmtSettings(fabricSettings, respObj):
    funcName = sys._getframe(0).f_code.co_name

    inbandMgmtEnable = True if (fabricSettings.get("INBAND_MGMT", "false") == "true") else False
    inbandMgmtEnablePrev = True if (fabricSettings.get("INBAND_MGMT_PREV", "false") == "true") else False
    bootstrapPOAPEnable = fabricSettings.get("BOOTSTRAP_ENABLE", "false")
    bootstrapPOAPEnablePrev = fabricSettings.get("BOOTSTRAP_ENABLE_PREV", "false")
    inbandPOAPEnable = True if (inbandMgmtEnable and bootstrapPOAPEnable == "true") else False
    inbandPOAPEnablePrev = True if (inbandMgmtEnablePrev and bootstrapPOAPEnablePrev == "true") else False
    dhcpEnable = fabricSettings.get("DHCP_ENABLE", "false")        
    tenantDhcpEnable = fabricSettings.get("ENABLE_TENANT_DHCP", "true")        
    underlayIsV6 = fabricSettings.get("UNDERLAY_IS_V6", "false")        
    routingProto = fabricSettings.get("LINK_STATE_ROUTING", "ospf")        
    fabIntfType = fabricSettings.get("FABRIC_INTERFACE_TYPE", "p2p")

    Wrapper.print("%s: inbandMgmtEnable [%r] inbandMgmtEnablePrev [%r] bootstrapPOAPEnable[%s] bootstrapPOAPEnablePrev[%s] "
      "inbandPOAPEnable [%r] inbandPOAPEnablePrev [%r] DHCP[%s] "
      "v6 [%s] Routing Prococol [%s]" % (funcName, inbandMgmtEnable, inbandMgmtEnablePrev, bootstrapPOAPEnable, bootstrapPOAPEnablePrev,
        inbandPOAPEnable, inbandPOAPEnablePrev, dhcpEnable, underlayIsV6, routingProto))
    
    # Disallow Inband Management for the following:
    #  - v6 Underlay
    #  - not OSPF Underlay Routing Protocol
    if inbandMgmtEnable and (underlayIsV6 == "true" or routingProto != "ospf"):
        respObj.addErrorReport(funcName, "Inband Management is supported only with IPv4 underlay and routing protocol as "
          "OSPF. Please update Fabric Settings and retry")
        respObj.setFailureRetCode()
        return

    if inbandPOAPEnable:
        if tenantDhcpEnable != "true":
          #Tenant DHCP knob must be enabled if inband POAP is enabled
          respObj.addErrorReport(funcName, "Tenant DHCP cannot be disabled if Inband POAP is enabled")
          respObj.setFailureRetCode()
          return

        if dhcpEnable == "false":
            # check the following for External DHCP Servers:
            #   - only 3 servers are allowed
            #   - IPv4 only
            settingName = "External DHCP Server IP Addresses"
            inbandDhcpServersSettting = fabricSettings.get("INBAND_DHCP_SERVERS", "")
            inbandDhcpServersList = [eachIP.strip() for eachIP in inbandDhcpServersSettting.split(',')]
            errMsg = None
            if len(inbandDhcpServersList) > 3:
                errMsg = "Please configure a maximum of 3 (three) %s." % (settingName)
            else:              
                for ip in inbandDhcpServersList:
                    if ":" in ip:
                        # v6 address is not allowed
                        errMsg = "%s must be valid IPv4 addresses." % (settingName)
                        break

            if errMsg is not None:
                respObj.addErrorReport("fabricInit:InbandDhcpServers", errMsg)
                respObj.setFailureRetCode()
                return

    if inbandMgmtEnable != inbandMgmtEnablePrev:
        if inbandMgmtEnable:
            # make sure the NDFC device management setting is 'Data'
            ndfcSNMPInfo = json.loads(Util.exe(FabricWrapper.getSNMPTrapInfo()))
            ndfcDevMgmtMode = ndfcSNMPInfo.get("global.oob_network_mode", "").lower()
            mgmtModeIsData = True if ndfcDevMgmtMode == "data" else False
            if not mgmtModeIsData:
                respObj.addErrorReport(funcName, "Inband Management is supported with 'LAN Device Management Connectivity' "
                  "Server Setting set to 'Data' only. Please update the setting and retry the management mode change.")
                respObj.setFailureRetCode()
                return respObj

        supportedSwitchRoles = ["leaf", "spine", "border", "broder spine", "border gateway", "border gateway spine"]
        topologyDataObj = TopologyData(Util.exe(TopologyWrapper.get(FABRIC_NAME)))
        devices = filter(None, (topologyDataObj.get(TopologyInfoType.SWITCHES)))  # all devices serial number
        for devSerial in devices:
            # make sure the switches are not in migration mode for some other reason
            ptiList = Util.exe(PTIWrapper.get(devSerial, "SWITCH", "SWITCH", "", "switch_migration_state"))
            for pti in ptiList:
                # switch already in migration mode.. check further and report erorr as needed
                if pti.isDeleted():
                    continue
                if (pti.getNvPairs().get("TARGET_MGMT_MODE", None) is None):
                    # switch is in some other migration mode.. report error
                    respObj.addErrorReport(funcName, "Switch is already in migration mode. Please complete associated "
                      "action and retry the management mode change.", devSerial)
                    respObj.setFailureRetCode()
                    continue

            if inbandMgmtEnable:
                # make sure the switch role is supported for Inband Mgmt
                switchRole = topologyDataObj.getSwitchRole(devSerial)
                if (switchRole.lower() not in supportedSwitchRoles):
                    respObj.addErrorReport(funcName, "Role [%s] is not supported for Inband Management." % (switchRole), devSerial)
                    respObj.setFailureRetCode()
                    continue

        if respObj.isRetCodeFailure():
            return respObj

        # do the following checks for the target mgmt mode before putting switches into migration mode
        # OOB:
        #   - mgmt0 intent must be present with a valid IP
        # Inband
        #   - bgp routing lo intf must be present with a valid IP
        #
        # target IP address must be pingable
        for devSerial in devices:
            targetMode = ("Inband" if inbandMgmtEnable else "OOB")

            Wrapper.print("%s: Switch [%s] Target Mgmt Mode [%s]" % (funcName, devSerial, targetMode))
            newDiscIP = None
            newDiscIntf = None
            intfTmplName = None
            if targetMode == "OOB":
                newDiscIntf = "mgmt0"
                intfTmplName = "int_mgmt"
            else:
                newDiscIntf = "loopback" + fabricSettings.get("BGP_LB_ID", "0")
                intfTmplName = "int_fabric_loopback_11_1"

            intfPti = None
            srchOpt = CtrlPolicySearch()
            srchOpt.setSerialNumber(devSerial)
            srchOpt.setEntityName(newDiscIntf)
            srchOpt.setTemplateName(intfTmplName)
            srchOpt.setTemplateContentType("PYTHON")
            intfPtis = Util.exe(PTIWrapper.getPTIs(srchOpt))
            for pti in intfPtis:
                if pti.isDeleted():
                    continue
                intfPti = pti
                break

            if intfPti is None:
                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+":DiscoveryIPChange"),
                               "Interface policy for interface [%s] not found. "
                               "Please double check and retry Recalculate & Deploy" % (newDiscIntf), devSerial)
                respObj.setFailureRetCode()
                continue

            if targetMode == "OOB":
                #   - make sure the mgmt0 intf intent is present to get the mgmt0 IP address
                intfFF = intfPti.getNvPairs().get("CONF", None)
                for line in intfFF.split(Util.newLine()):
                    stripLine = line.strip()
                    if stripLine.startswith("ip address "):
                        parts = stripLine.split(" ")
                        newDiscIP = parts[2].split("/")[0]
                        break
            else:
                #   - make sure the lo0 intf intent is present to get the IP address
                newDiscIP = intfPti.getNvPairs().get("IP", None)

            if newDiscIP is None:
                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+":DiscoveryIPChange"),
                     "IP address for interface [%s] not found. "
                     "Please double check and retry changing the 'Inband Management' fabric settings." % (newDiscIntf), devSerial)
                respObj.setFailureRetCode()
                continue

            # make sure the target IP is pingable
            # cmd = "ping -i .5 -c 2 -t 2 -W 2 " + newDiscIP
            # Wrapper.print("%s: IP rechability check with [%s]"%(funcName, cmd))

            # response = os.system(cmd)
            # if response != 0:
            #     respObj.addErrorReport(getFabErrEntity(funcName, devSerial+":DiscoveryIPChange"),
            #          "IP address [%s] for interface [%s] is not reachable. "
            #          "Please double check and retry changing the 'Inband Management' fabric settings." % (newDiscIP, newDiscIntf), devSerial)
            #     respObj.setFailureRetCode()
            #     return respObj

        if respObj.isRetCodeFailure():
            return respObj

        # pre-conditions are met.. put switches in migration mode to allow the OOB <--> Inband mgmt change
        for devSerial in devices:
            ptiList = Util.exe(PTIWrapper.get(devSerial, "SWITCH", "SWITCH", "", "switch_migration_state"))
            for pti in ptiList:
                PTIWrapper.deleteInstance(pti.getPolicyId());
            nvPairs = {"TARGET_MGMT_MODE" : "Inband" if inbandMgmtEnable else "OOB"}
            Util.exe(PTIWrapper.create(devSerial, "SWITCH", "SWITCH", "", 10,
                                  "switch_migration_state", nvPairs, "Management mode change"))
        
def preUpgrade(dictionaryObj):
    Wrapper.print("==========ACTION: FAB [%s]: Start: preUpgrade" % (FABRIC_NAME))
    respObj = WrappersResp.getRespObj()
    respObj.setSuccessRetCode()
    try:
        upgFromVer = dictionaryObj.get("UPGRADE_FROM", "")
        Wrapper.print("==========preUpgrade: Fabric Name = %s, keys = %d, UPGRADE_FROM = [%s]" %
                (FABRIC_NAME, len(dictionaryObj), upgFromVer))
        dictionaryObj["FABRIC_NAME"] = FABRIC_NAME
        respObj = Util.exe(PTI.executePyTemplateMethod("fabric_upgrade_11_1", dictionaryObj, "preUpgradeExt"))
    except respObjError as e:
        respObj = e.value
    finally:
        Wrapper.print("==========ACTION: FAB [%s]: Finish: preUpgrade: Success = [%r]" %
                (FABRIC_NAME, respObj.isRetCodeSuccess()))
        return respObj

def isInbandPoapEnabled(dictObj):
    inbandMgmt = dictObj.get("INBAND_MGMT", "false")
    bootstrapPOAPEnable = dictObj.get("BOOTSTRAP_ENABLE", "false")
    return ("true" if (inbandMgmt == "true" and bootstrapPOAPEnable == "true") else "false")

def fabricInit(dictionaryObj):
    newLine = Util.newLine()
    global FABRIC_INTERFACE_TYPE, REPLICATION_MODE, FEATURE_PTP, VPC_DOMAIN_ID_RANGE, SITE_ID, BANNER, SGT_ID_RANGE
    funcName = sys._getframe(0).f_code.co_name
    Wrapper.print("==========ACTION: FAB [%s]: Start: %s" % (FABRIC_NAME, funcName))
    respObj = WrappersResp.getRespObj()
    respObj.setSuccessRetCode()

    try:
        Util.exe(actionAllow())

        fabricSettings = Util.exe(FabricWrapper.get(FABRIC_NAME)).getNvPairs()
        fabricSettings["FABRIC_TYPE"] = "Switch_Fabric"

        inbandMgmt = fabricSettings.get("INBAND_MGMT", "false")
        bootstrapPOAPEnable = fabricSettings.get("BOOTSTRAP_ENABLE", "false")
        bootstrapPOAPEnablePrev = fabricSettings.get("BOOTSTRAP_ENABLE_PREV", "false")
        inbandPOAPEnable = "true" if (inbandMgmt == "true" and bootstrapPOAPEnable == "true") else "false"

        checkInbandMgmtSettings(fabricSettings, respObj)
        if respObj.isRetCodeFailure():
            return respObj

        failStr = isValidBrownfieldNetworkFormat(BROWNFIELD_NETWORK_NAME_FORMAT)
        if failStr:
            respObj.addErrorReport(funcName,
                "The network name format [%s] used for Brownfield import is invalid. Reason - %s. Please refer to the documentation for additional information." %
                (BROWNFIELD_NETWORK_NAME_FORMAT, failStr))
            respObj.setFailureRetCode()
            return respObj

        # check the fabric wide links extra config
        errCmd, adjFabricExtraLinkCfg = Util.getAdjustedIntfFreeformConfig(EXTRA_CONF_INTRA_LINKS)
        if errCmd != "":
            respObj.addErrorReport(funcName,
                "The Intra fabric link interface freeform extra configuration must not contain the \'interface\' keyword. Please remove the command %s" %
                (errCmd))
            respObj.setFailureRetCode()
            return respObj

        # validate the OSPF Area ID
        if OSPF_AREA_ID != "":
            if not Util.isValidOspfAreaIdIPString(OSPF_AREA_ID):
               respObj.addErrorReport(funcName,
                "[%s] - Invalid OSPF Area ID IP String. Please make sure the IP address is valid and contains no white spaces." % OSPF_AREA_ID)
               respObj.setFailureRetCode()
               return respObj

        # validate ANYCAST_GW_MAC
        agw_mac = Util.normalizeMac(ANYCAST_GW_MAC)
        if int(agw_mac[0:2], 16) & 0x01 != 0:
            respObj.addErrorReport(funcName, "Anycast Gateway MAC needs to be unicast mac address. ")
            respObj.setFailureRetCode()
            return respObj

        pmEnable = fabricSettings.get("PM_ENABLE", "false")
        pmEnablePrev = fabricSettings.get("PM_ENABLE_PREV", "false")
        if pmEnable != pmEnablePrev:
            turnOnPM = True if pmEnable == "true" else False
            isFeatEnabled = Util.exe(FabricWrapper.isFeatureEnabled("pm"))
            if isFeatEnabled:
                FabricWrapper.enOrDisFabricPM(FABRIC_NAME, turnOnPM)
            else:
                pmForceUpd = "false" if fabricSettings.get("PM_FORCE_UPD", "true") == "true" else "true"
                FabricWrapper.update(FABRIC_NAME,"PM_FORCE_UPD", pmForceUpd)
                respObj.addErrorReport(funcName, "Performance Monitoring feature is not started. "
                                       "Please start Performance Monitoring from Feature Management and retry this operation.")
                respObj.setFailureRetCode()
                return respObj

        # Security Groups (SGM) related
        sgtEnableTmpltVar = fabricSettings.get("ENABLE_SGT", "false")
        sgtEnablePrevTmpltVar = fabricSettings.get("ENABLE_SGT_PREV", "false")
        sgtEnable = sgtEnableTmpltVar == "true"

        sgtChgdToEnable = (sgtEnableTmpltVar != sgtEnablePrevTmpltVar and sgtEnableTmpltVar == "true")
        sgtChgdToDisable = (sgtEnableTmpltVar != sgtEnablePrevTmpltVar and sgtEnableTmpltVar == "false")

        Wrapper.print("==sgtEnable flap status [%s], disable flap status [%s], sgt Enable status [%s]"%
                      (sgtChgdToEnable, sgtChgdToDisable, sgtEnable))

        sgtPreprovTmpltVar = fabricSettings.get("SGT_PREPROVISION", "false")
        sgtPreprovPrevTmpltVar = fabricSettings.get("SGT_PREPROVISION_PREV", "false")
        sgtPreprovChgd = (sgtPreprovTmpltVar != sgtPreprovPrevTmpltVar)
        Wrapper.print("==sgtPreprovChgd status [%s]"%(sgtPreprovChgd))

        if sgtEnable:
            if (Util.exe(ChangeMgmtWrapper.getTicketId()) != ""):
                # report error if Change Control is enabled
                respObj.addErrorReport(funcName, "Security Groups feature is not supported with Change Control feature. %s"
                                       "Please disable Change Control feature and retry this operation."%(newLine))
                respObj.setFailureRetCode()
                return respObj

            overlayMode = fabricSettings.get("OVERLAY_MODE", "cli")
            if overlayMode == "config-profile":
                respObj.addErrorReport(funcName, "Security Groups feature is only supported with cli Overlay Mode option.")
                respObj.setFailureRetCode()
                return respObj

        # check this way so no ambiguity for child fabric irrespetive of child/parent state
        isChildFabric = Util.exe(FabricWrapper.isChidFabric(FABRIC_NAME))
        if isChildFabric:
            msdFabricName = Util.exe(FabricWrapper.getParentFabricName(FABRIC_NAME))
            msdFabricSettings = Util.exe(FabricWrapper.get(msdFabricName)).getNvPairs()

            chSgtEn = fabricSettings.get("ENABLE_SGT", "false") == "true"
            isStrictSgtEn = msdFabricSettings.get("ENABLE_SGT", "off") == "strict"
            isLooseSgtEn = msdFabricSettings.get("ENABLE_SGT", "off") == "loose"
            msdSgtEn =  isStrictSgtEn or isLooseSgtEn

            chSgtNamePfx = fabricSettings.get("SGT_NAME_PREFIX", "SG_")
            msdSgtNamePfx = msdFabricSettings.get("SGT_NAME_PREFIX", "SG_")

            chSgtIdRange = fabricSettings.get("SGT_ID_RANGE", "10000-14000")
            msdSgtIdRange = msdFabricSettings.get("SGT_ID_RANGE", "10000-14000")

            chSgtPreProvEn = fabricSettings.get("SGT_PREPROVISION", "false") == "true"
            msdSgtPreProvEn = msdFabricSettings.get("SGT_PREPROVISION", "false") == "true"

            Wrapper.print("==SG settings chSgtEn=[%s], msdSgtEn=[%s], isStrictSgtEn=[%s], "
                          "chSgtNamePfx=[%s], msdSgtNamePfx=[%s], chSgtIdRange=[%s], "
                          "msdSgtIdRange=[%s], chSgtPreProvEn=[%s], msdSgtPreProvEn=[%s]."%
                          (chSgtEn, msdSgtEn, isStrictSgtEn, chSgtNamePfx, msdSgtNamePfx,
                           chSgtIdRange, msdSgtIdRange, chSgtPreProvEn, msdSgtPreProvEn))
            msdSgtRecalPending = msdFabricSettings.get("SGT_RECALC_STATUS", "empty") == "start"
            msdPreProvRecalPending = msdFabricSettings.get("SGT_PREPROV_RECALC_STATUS", "empty") == "start"
            
            if not msdSgtEn and chSgtEn:
                respObj.addErrorReport(funcName, "Security Group is not enabled in Fabric Group %s. Please enable in Fabric Group before enabling Security Groups in the member fabric."%(msdFabricName))
                respObj.setFailureRetCode()
                return respObj

            if (isStrictSgtEn and
                (chSgtEn != msdSgtEn or chSgtNamePfx != msdSgtNamePfx or 
                 chSgtIdRange != msdSgtIdRange or chSgtPreProvEn != msdSgtPreProvEn)):
                 # It is a member of MSD. Do not allow SG enable when it is a child fabric
                 respObj.addErrorReport(funcName, "Security Groups option(s) have changed in the member fabric. %s"
                                        "Security Groups option(s) can be changed only from the Fabric Group in Strict Security Group mode."%(newLine))
                 respObj.setFailureRetCode()
                 return respObj

            #if (msdSgtRecalPending or msdPreProvRecalPending) and (sgtChgdToEnable or sgtChgdToDisable) :
            #    respObj.addErrorReport(funcName, "Recalculate and deploy is pending in MSD fabric %s. Please complete it before enabling/disabling Security Groups in the member fabric."%(msdFabricName))
            #    respObj.setFailureRetCode()
            #    return respObj

            if isLooseSgtEn and sgtEnable and sgtChgdToEnable:
                topologyDataObj = TopologyData(Util.exe(TopologyWrapper.get(FABRIC_NAME))) #child
                devices = topologyDataObj.get(TopologyInfoType.SWITCHES)
                devices = filter(None, devices)
                #fabricSettings  = Util.exe(FabricWrapper.get(FABRIC_NAME)).getNvPairs()
                memberFabricInfoDict = {"FABRIC_NAME":FABRIC_NAME, "topologyDataObj":topologyDataObj, "devices":devices}
                respObj = PTI.executePyTemplateMethod("fabric_utility_11_1", memberFabricInfoDict, "checkSGTSettings")
                if respObj.isRetCodeFailure():
                   return respObj

            if isLooseSgtEn and chSgtEn:
                Wrapper.print("%s: Fabric %s is a child in loose mode. Checking child and Fabric Group settings" % (funcName, FABRIC_NAME))
                # Set the following parameters to parent MSD value
                if chSgtNamePfx != msdSgtNamePfx:
                    Wrapper.print("%s: Child fabric [%s] Sg name prefix [%s] does not match Fabric Group Sg name prefix [%s]."
                                  % (funcName, FABRIC_NAME, chSgtNamePfx, msdSgtNamePfx))
                    if sgtChgdToEnable:
                        # Since user enabled SG in the child, borrow other SG options from the parent 
                        # if name prefix is the default value, else throw an error
                        if chSgtNamePfx == "SG_":
                            fabricSettings["SGT_NAME_PREFIX"] = msdSgtNamePfx
                            Wrapper.print("%s: Updating Child fabric [%s] Sg name prefix [%s] to Fabric Group Sg name prefix [%s] " 
                                          "since user enabled SG in child" % (funcName, FABRIC_NAME, chSgtNamePfx, msdSgtNamePfx))
                        else:
                            respObj.addErrorReport(funcName, "Mismatch in Security Group Name Prefix option for child fabric [%s] and Fabric Group [%s]. %s"
                                                  "Security Group Name Prefix in Fabric Group is [%s]" % (FABRIC_NAME, msdFabricName, newLine, msdSgtNamePfx))
                            respObj.setFailureRetCode()
                            return respObj
                    else:
                        respObj.addErrorReport(funcName, "Security Group Name Prefix option cannot be changed in the member fabric directly. %s"
                                              "Please change it from the Fabric Group settings."%(newLine))
                        respObj.setFailureRetCode()
                        return respObj
                if chSgtIdRange != msdSgtIdRange:
                    Wrapper.print("%s: Child fabric [%s] Sgt ID Range [%s] does not match Fabric Group Sgt ID Range [%s]."
                                  % (funcName, FABRIC_NAME, chSgtIdRange, msdSgtIdRange))
                    if sgtChgdToEnable:
                        # Since user enabled SG in the child, borrow other SG options from the parent 
                        # if sgt range is the default value, else throw an error
                        if chSgtIdRange == "10000-14000":
                            fabricSettings["SGT_ID_RANGE"] = msdSgtIdRange
                            Wrapper.print("%s: Updating Child fabric [%s] Sgt ID Range [%s] to Fabric Group Sgt ID Range [%s]."
                                          % (funcName, FABRIC_NAME, chSgtIdRange, msdSgtIdRange))
                        else:
                            respObj.addErrorReport(funcName, "Mismatch in Security Group ID Range option for child fabric [%s] and Fabric Group [%s]. %s"
                                                  "Security Group ID Range in Fabric Group is [%s]" % (FABRIC_NAME, msdFabricName, newLine, msdSgtIdRange))
                            respObj.setFailureRetCode()
                            return respObj
                    else:
                        respObj.addErrorReport(funcName, "Security Group Tag ID Range option cannot be changed in the member fabric directly. %s"
                                              "Please change it from the Fabric Group settings."%(newLine))
                        respObj.setFailureRetCode()
                        return respObj
                if chSgtPreProvEn != msdSgtPreProvEn:
                    preProv = "false"
                    if msdSgtPreProvEn:
                        preProv = "true"
                    sgtPreprovTmpltVar = preProv
                    sgtPreprovChgd = True
                    Wrapper.print("%s: Child fabric [%s] SG Pre-provision [%s] does not match Fabric Group SG Pre-provision [%s]. sgtPreprovChgd [%s]"
                                  % (funcName, FABRIC_NAME, chSgtPreProvEn, msdSgtPreProvEn, sgtPreprovChgd))
                    if sgtChgdToEnable:
                        # Since user enabled SG in the child, borrow other SG options from the parent 
                        # if pre-provision is the default value, else throw an error
                        if not chSgtPreProvEn:
                            fabricSettings["SGT_PREPROVISION"] = preProv
                            Wrapper.print("%s: Updating Child fabric [%s] SG Pre-provision [%s] to Fabric Group SG Pre-provision [%s]"
                                          % (funcName, FABRIC_NAME, chSgtPreProvEn, msdSgtPreProvEn))
                        else:
                            respObj.addErrorReport(funcName, "Mismatch in Security Group Pre-provision option for child fabric [%s] and Fabric Group [%s]. %s"
                                                  "Security Group Pre-provision in Fabric Group is [%s]" % (FABRIC_NAME, msdFabricName, newLine, msdSgtPreProvEn))
                            respObj.setFailureRetCode()
                            return respObj
                    else:
                        respObj.addErrorReport(funcName, "Security Groups Pre-provision option cannot be changed in the member fabric directly. %s"
                                              "Please change it from the Fabric Group settings."%(newLine))
                        respObj.setFailureRetCode()
                        return respObj

    	#Validate BGP AS number
        Util.exe(Helper.isValidAsn(BGP_AS))

        # validate Site ID
        # This is a non mandatory parameter and input can be the following:
        #   > empty - in this case, we will set it to the BGP_AS
        #   > X - if integer, need validaiton to make sure it is within the range
        #   > X.Y - may or not be the same as BGP AS. Same validation rules as BGP ASN. 
        #           Update the fabric settings with the equivalent decimal value using siteId = (65536 * X) + Y
        newSiteId = SITE_ID
        updateSiteId = False
        if SITE_ID == "":
            Wrapper.print("%s: Setting Site ID to BGP_AS [%s]" % (funcName, BGP_AS))
            newSiteId = BGP_AS

        match = re.search('''\.''', newSiteId)
        if match:
            # Site ID is in the X.Y format
            tokens = newSiteId.split('.')
            if len(tokens) == 2:
                # make sure the Site ID passes the BGP AS validation rules
                rObj = Helper.isValidAsn(newSiteId)
                if rObj.isRetCodeFailure():
                   respObj.addErrorReport(funcName, "SITE ID is invalid. Please follow BGP AS number requirements.")
                   respObj.setFailureRetCode()
                   return respObj

                newSiteId = str(int(65536 * int(tokens[0])) + int (tokens[1]))
                Wrapper.print("%s: token1: [%s] token 2: [%s]. Site ID = [%s]" %(funcName, tokens[0], tokens[1], newSiteId))
                updateSiteId = True
        else:
           match   = re.search('(^[0-9]+$)', newSiteId)
           if match is None:
               respObj.addErrorReport(funcName, "SITE ID is invalid. Valid values: <1-281474976710655>")
               respObj.setFailureRetCode()
               return respObj
           else:
               site_id_int = long(newSiteId)
               if site_id_int < 1 or site_id_int > 281474976710655:
                   respObj.addErrorReport(funcName, "SITE ID not valid. Valid values: <1-281474976710655>")
                   respObj.setFailureRetCode()
                   return respObj
               elif SITE_ID != newSiteId:
                   updateSiteId = True

        Wrapper.print("%s: SITE_ID: [%s] newSiteId [%s] updateSiteId [%r]" %(funcName, SITE_ID, newSiteId, updateSiteId))
        if updateSiteId:
            SITE_ID = newSiteId
            fabricSettings["SITE_ID"] = SITE_ID
            #Util.exe(Helper.setFabricSiteId(FABRIC_NAME, newSiteId))

        try:
            getRespObj = FabricWrapper.getParentFabricName(FABRIC_NAME)
            if getRespObj.isRetCodeSuccess():
                parentFabric = getRespObj.getValue()
                msLoopbackId = Util.exe(FabricWrapper.get(parentFabric, "MS_LOOPBACK_ID"))
                if msLoopbackId == BGP_LB_ID or msLoopbackId == NVE_LB_ID:
                    errorMsg = ("Cannot change 'Underlay %s Loopback Id' to %s since "
                        "it conflicts with 'Multi-site Routing Loopback Id' in parent fabric [%s]"
                        % ("Routing" if msLoopbackId==BGP_LB_ID else "NVE", BGP_LB_ID if msLoopbackId==BGP_LB_ID else NVE_LB_ID, parentFabric))
                    Wrapper.print("%s: %s" % (funcName, errorMsg))
                    respObj.addErrorReport(funcName, errorMsg)
                    respObj.setFailureRetCode()
                    return respObj
        except:
            Wrapper.print("exception, ignore if not member fabric")
            pass

        # validate BANNER
        if BANNER.strip():
            BANNER=BANNER.strip()
            if len(BANNER) < 3:
                errorMsg = ("Banner field needs to be delimiter char followed by non-empty message ending with delimiter ")
                Wrapper.print("%s: %s" % (funcName, errorMsg))
                respObj.addErrorReport(funcName, errorMsg)
                respObj.setFailureRetCode()
                return respObj

            if BANNER[0] != BANNER[-1]:
                errorMsg = ("Banner field's starting char '%s' and ending char '%s' do not match. Banner field needs to be delimiter char followed by message ending with delimiter"%(BANNER[0], BANNER[-1]))
                Wrapper.print("%s: %s" % (funcName, errorMsg))
                respObj.addErrorReport(funcName, errorMsg)
                respObj.setFailureRetCode()
                return respObj
            if BANNER[0] in BANNER[1:-1]:
                errorMsg = ("Banner field using '%s' as delimiter cannot have '%s' inside banner message" %(BANNER[0], BANNER[0]))
                Wrapper.print("%s: %s" % (funcName, errorMsg))
                respObj.addErrorReport(funcName, errorMsg)
                respObj.setFailureRetCode()
                return respObj

        if UNDERLAY_IS_V6 == "true":
            if FABRIC_INTERFACE_TYPE != "p2p":
                fabricSettings["FABRIC_INTERFACE_TYPE"] = "p2p"
                FABRIC_INTERFACE_TYPE = "p2p"

            if FEATURE_PTP != "false":
                fabricSettings["FEATURE_PTP"] = "false"
                FEATURE_PTP = "false"

        # Initialize IsShow dependent variables to their default values if
        # they are set to blank by the backend because the IsShow evaluation is False.
        # Only variables that are identified to show different behavior from 11.3 if
        # they are left blank are initialized.
        if UNDERLAY_IS_V6 == "":
            fabricSettings["UNDERLAY_IS_V6"] = "false"
        if USE_LINK_LOCAL == "":
            fabricSettings["USE_LINK_LOCAL"] = "true"
        if ENABLE_DEFAULT_QUEUING_POLICY == "":
            fabricSettings["ENABLE_DEFAULT_QUEUING_POLICY"] = "false"
        if FABRIC_VPC_QOS == "":
            fabricSettings["FABRIC_VPC_QOS"] = "false"
        if GRFIELD_DEBUG_FLAG == "":
            fabricSettings["GRFIELD_DEBUG_FLAG"] = "Disable"
        if MPLS_HANDOFF == "":
            fabricSettings["MPLS_HANDOFF"] = "false"
        if MPLS_ISIS_AREA_NUM == "":
            fabricSettings["MPLS_ISIS_AREA_NUM"] = "0001"

        if FABRIC_INTERFACE_TYPE == "":
            fabricSettings["FABRIC_INTERFACE_TYPE"] = "p2p"
        if SUBNET_TARGET_MASK == "":
            fabricSettings["SUBNET_TARGET_MASK"] = "30"
        if V6_SUBNET_TARGET_MASK == "":
            fabricSettings["V6_SUBNET_TARGET_MASK"] = "126"
        if REPLICATION_MODE == "":
            fabricSettings["REPLICATION_MODE"] = "Multicast"
        if ENABLE_TRM == "":
            fabricSettings["ENABLE_TRM"] = "false"
        if RP_MODE == "":
            fabricSettings["RP_MODE"] = "asm"
        if RP_COUNT == "":
            fabricSettings["RP_COUNT"] = "2"
        if FABRIC_VPC_QOS_POLICY_NAME == "":
            fabricSettings["FABRIC_VPC_QOS_POLICY_NAME"] = "spine_qos_for_fabric_vpc_peering"
        if OSPF_AUTH_ENABLE == "":
           fabricSettings["OSPF_AUTH_ENABLE"] = "false"
        if ISIS_LEVEL == "":
           fabricSettings["ISIS_LEVEL"] = "level-2"
        if ISIS_AREA_NUM == "":
           fabricSettings["ISIS_AREA_NUM"] = "0001"
        if ISIS_AUTH_ENABLE == "":
            fabricSettings["ISIS_AUTH_ENABLE"] = "false"
        if BGP_AUTH_ENABLE == "":
            fabricSettings["BGP_AUTH_ENABLE"] = "false"
        if BGP_AUTH_KEY_TYPE == "":
            fabricSettings["BGP_AUTH_KEY_TYPE"] = "3"
        if PIM_HELLO_AUTH_ENABLE == "":
            fabricSettings["PIM_HELLO_AUTH_ENABLE"] = "false"
        if BFD_ENABLE == "":
            fabricSettings["BFD_ENABLE"] = "false"
        if BFD_IBGP_ENABLE == "":
            fabricSettings["BFD_IBGP_ENABLE"] = "false"
        if BFD_OSPF_ENABLE == "":
            fabricSettings["BFD_OSPF_ENABLE"] = "false"
        if BFD_ISIS_ENABLE == "":
            fabricSettings["BFD_ISIS_ENABLE"] = "false"
        if BFD_PIM_ENABLE == "":
            fabricSettings["BFD_PIM_ENABLE"] = "false"
        if BFD_AUTH_ENABLE == "":
            fabricSettings["BFD_AUTH_ENABLE"] = "false"
        if ENABLE_NXAPI_HTTP == "":
            fabricSettings["ENABLE_NXAPI_HTTP"] = "true"
        if NXAPI_HTTPS_PORT == "":
            fabricSettings["NXAPI_HTTPS_PORT"] = "443"
        if NXAPI_HTTP_PORT == "":
            fabricSettings["NXAPI_HTTP_PORT"] = "80"
        if FEATURE_PTP == "":
            fabricSettings["FEATURE_PTP"] = "false"
        if ENABLE_DEFAULT_QUEUING_POLICY == "":
            fabricSettings["ENABLE_DEFAULT_QUEUING_POLICY"] = "false"
        if DEAFULT_QUEUING_POLICY_CLOUDSCALE == "":
            fabricSettings["DEAFULT_QUEUING_POLICY_CLOUDSCALE"] = "queuing_policy_default_8q_cloudscale"
        if DEAFULT_QUEUING_POLICY_R_SERIES == "":
            fabricSettings["DEAFULT_QUEUING_POLICY_R_SERIES"] = "queuing_policy_default_r_series"
        if DEAFULT_QUEUING_POLICY_OTHER == "":
            fabricSettings["DEAFULT_QUEUING_POLICY_OTHER"] = "queuing_policy_default_other"

        if ENABLE_AI_ML_QOS_POLICY == "":
            fabricSettings["ENABLE_AI_ML_QOS_POLICY"] = "false"
        if ENABLE_AI_ML_QOS_POLICY_FLAP == "":
            fabricSettings["ENABLE_AI_ML_QOS_POLICY_FLAP"] = "false"
        if AI_ML_QOS_POLICY == "":
            fabricSettings["AI_ML_QOS_POLICY"] = "AI_Fabric_QOS_400G"

        if STP_ROOT_OPTION == "":
            fabricSettings["STP_ROOT_OPTION"] = "unmanaged"

        if AUTO_SYMMETRIC_VRF_LITE == "":
            fabricSettings["AUTO_SYMMETRIC_VRF_LITE"] = "false"
        if AUTO_VRFLITE_IFC_DEFAULT_VRF == "":
            fabricSettings["AUTO_VRFLITE_IFC_DEFAULT_VRF"] = "false"
        if AUTO_SYMMETRIC_DEFAULT_VRF == "":
            fabricSettings["AUTO_SYMMETRIC_DEFAULT_VRF"] = "false"

        if DHCP_ENABLE == "":
            fabricSettings["DHCP_ENABLE"] = "false"
        if DHCP_ENABLE == "true" and DHCP_IPV6_ENABLE == "":
            fabricSettings["DHCP_IPV6_ENABLE"] = "DHCPv4"
            fabricSettings["MGMT_PREFIX"] = "24"
        if ENABLE_AAA == "":
            fabricSettings["ENABLE_AAA"] = "false"
        if VPC_DOMAIN_ID_RANGE == "":
            VPC_DOMAIN_ID_RANGE = "1-1000"
            fabricSettings["VPC_DOMAIN_ID_RANGE"] = VPC_DOMAIN_ID_RANGE
        if OVERLAY_MODE == "":
            fabricSettings["OVERLAY_MODE"] = "config-profile"
        if HOST_INTF_ADMIN_STATE == "":
            fabricSettings["HOST_INTF_ADMIN_STATE"] = "true"

        fabricSettings["ENABLE_SGT_PREV"] = sgtEnableTmpltVar
        fabricSettings["SGT_PREPROVISION_PREV"] = sgtPreprovTmpltVar

        fabricSettings["PM_ENABLE_PREV"] = pmEnable
        fabricSettings["INBAND_MGMT_PREV"] = inbandMgmt 
        fabricSettings["BOOTSTRAP_ENABLE_PREV"] = bootstrapPOAPEnable     
        # show the example if DHCP is enabled later
        if DHCP_ENABLE != "true" and BOOTSTRAP_MULTISUBNET == "":
            fabricSettings["BOOTSTRAP_MULTISUBNET"] = "#Scope_Start_IP, Scope_End_IP, Scope_Default_Gateway, Scope_Subnet_Prefix"
        
        # update the template names that have changed from 11.x
        if temp_vpc_peer_link == "int_vpc_peer_link_po_11_1":
            fabricSettings["temp_vpc_peer_link"] = "int_vpc_peer_link_po"
        if abstract_routed_host == "int_routed_host_11_1":
            fabricSettings["abstract_routed_host"] = "int_routed_host"
        if abstract_trunk_host == "int_trunk_host_11_1":
            fabricSettings["abstract_trunk_host"] = "int_trunk_host"
        if sgtChgdToEnable or sgtChgdToDisable:
            fabricSettings["SGT_RECALC_STATUS"] = "start"

        if sgtPreprovChgd:
            fabricSettings["SGT_PREPROV_RECALC_STATUS"] = "start"

        FabricWrapper.update(FABRIC_NAME, fabricSettings)

        if REPLICATION_MODE == "Multicast":
            #Verify that mask length for multicast subnet is between 8 and 30
            if UNDERLAY_IS_V6 != "true":
                tokens = MULTICAST_GROUP_SUBNET.split("/")
                if len(tokens) == 2:
                    prefix = int(tokens[1])
                    if prefix < 8 or prefix > 30:
                        respObj.addErrorReport(funcName,
                              "Multicast subnet prefix length supported is 8 - 30: Value: "+ str(prefix))
                        respObj.setFailureRetCode()
                        return respObj
                else:
                    Wrapper.print("fabricInit: MULTICAST_GROUP_SUBNET: Tokens equal:" + str(len(tokens)))
                    respObj.addErrorReport(funcName, "Multicast subnet invalid: " + MULTICAST_GROUP_SUBNET)
                    respObj.setFailureRetCode()
                    return respObj

                respObj = Helper.isValidIPv4MCAddress(MULTICAST_GROUP_SUBNET)
                if respObj.isRetCodeFailure():
                    return respObj
                else:
                    Wrapper.print("fabricInit: MC group subnet is Valid")
            else:
                # validate IPv6_MULTICAST_GROUP_SUBNET
                tokens = IPv6_MULTICAST_GROUP_SUBNET.split("/")
                if len(tokens) == 2:
                    Wrapper.print("fabricInit: IPv6_MULTICAST_GROUP_SUBNET: Tokens equal 2")
                    prefix = int(tokens[1])
                    if prefix < 112 or prefix > 128:
                        respObj.addErrorReport("fabricInit", "IPv6 Multicast Group Subnet prefix length supported is 112 - 128: Value: " + str(prefix))
                        respObj.setFailureRetCode()
                        return respObj
                else:
                    Wrapper.print("fabricInit: IPv6_MULTICAST_GROUP_SUBNET: Tokens equal:" + str(len(tokens)))
                    respObj.addErrorReport("fabricInit", "IPv6 Multicast Group Subnet invalid: " + IPv6_MULTICAST_GROUP_SUBNET)
                    respObj.setFailureRetCode()
                    return respObj

                if IPv6_MULTICAST_GROUP_SUBNET[0:2].lower() != "ff":
                    Wrapper.print("fabricInit: IPv6_MULTICAST_GROUP_SUBNET: address not starts with 'FF'")
                    respObj.addErrorReport("fabricInit", "IPv6 Multicast Group Subnet needs to start with 'ff'. Invalid input: " + IPv6_MULTICAST_GROUP_SUBNET)
                    respObj.setFailureRetCode()
                    return respObj

                if RP_MODE == "bidir":
                    Wrapper.print("fabricInit: IPv6 underlay does not support multicast RP Mode as 'bidir'")
                    respObj.addErrorReport(funcName, "VXLAN EVPN fabric with IPv6 underlay does not support 'bidir' multicast RP mode")
                    respObj.setFailureRetCode()
                    return respObj

            try:
                enableTrmv6 = ENABLE_TRMv6
                l3vniIpv6McastGroup = L3VNI_IPv6_MCAST_GROUP
            except:
                enableTrmv6 = "false"
                l3vniIpv6McastGroup = ""
            if ENABLE_TRM == "true" or enableTrmv6 == "true":
                if UNDERLAY_IS_V6 != "true" and L3VNI_MCAST_GROUP != "":
                    addr, prefix = MULTICAST_GROUP_SUBNET.split("/")
                    mcastGroupSubnet = Util.getSubnetStringWithPrefix(addr, prefix)
                    mdtAddressSubnet = Util.getSubnetStringWithPrefix(L3VNI_MCAST_GROUP, prefix)
                    if mcastGroupSubnet != mdtAddressSubnet:
                        errorMsg = ("Default MDT IPv4 address for TRM VRFs [%s] must be an address "
                                    "within the underlay multicast group subnet [%s]" %
                                    (L3VNI_MCAST_GROUP, MULTICAST_GROUP_SUBNET))
                        respObj.addErrorReport(funcName, errorMsg)
                        respObj.setFailureRetCode()
                        return respObj
                elif UNDERLAY_IS_V6 == "true" and l3vniIpv6McastGroup != "":
                    addr, prefix = IPv6_MULTICAST_GROUP_SUBNET.split("/")
                    mcastGroupSubnet = Util.getV6SubnetStringWithPrefix(addr, prefix)
                    mdtAddressSubnet = Util.getV6SubnetStringWithPrefix(L3VNI_IPv6_MCAST_GROUP, prefix)
                    if mcastGroupSubnet != mdtAddressSubnet:
                        errorMsg = ("Default MDT IPv6 address for TRM VRFs [%s] must be an address "
                                    "within the underlay IPv6 multicast group subnet [%s]" %
                                    (L3VNI_IPv6_MCAST_GROUP, IPv6_MULTICAST_GROUP_SUBNET))
                        respObj.addErrorReport("fabricInit", errorMsg)
                        respObj.setFailureRetCode()
                        return respObj

            if enableTrmv6 == "true" and MPLS_HANDOFF == "true":
                respObj.addErrorReport("fabricInit", "IPv6 Tenant Routed Multicast and MPLS Handoff cannot co-exist. Please disable one of them")
                respObj.setFailureRetCode()
                return respObj

            if RP_MODE == "bidir":
                if ENABLE_TRM == "true":
                    Wrapper.print("fabricInit: TRM cannot be enabled while multicast RP Mode is 'bidir'")
                    respObj.addErrorReport(funcName, "TRM cannot be enabled while multicast RP Mode is 'bidir'")
                    respObj.setFailureRetCode()
                    return respObj

                # Verify that mask length for RP subnet for PIM Bidir must be 24
                tokens = ANYCAST_RP_IP_RANGE.split("/")
                Wrapper.print("fabricInit: ANYCAST_RP_IP_RANGE: Tokens [%d]" % (len(tokens)))
                if len(tokens) == 2:
                    prefix = int(tokens[1])
                    if prefix != 24:
                        respObj.addErrorReport(funcName, "Phantom RP subnet prefix length must be 24: Value: " + str(prefix))
                        respObj.setFailureRetCode()
                        return respObj
                else:
                    respObj.addErrorReport(funcName, "RP subnet invalid: " + ANYCAST_RP_IP_RANGE)
                    respObj.setFailureRetCode()
                    return respObj
        else:
            Wrapper.print("fabricInit: Not validating MC/RP Subnet as mode is: " + REPLICATION_MODE)

            if ENABLE_TRM == "true":
                Wrapper.print("fabricInit: TRM can not be enabled while Replication Mode is Ingress")
                respObj.addErrorReport(funcName, "TRM can not be enabled while Replication Mode is Ingress")
                respObj.setFailureRetCode()
                return respObj

        dict = getGlobals()
        dict["GLOBALS_SET"] = False
        processRespObj(respObj, PTI.executePyTemplateMethod("Easy_Fabric_Extn_11_1", dict, "sanityCheckLoopbackId"))
        if respObj.isRetCodeFailure():
            return respObj

        Wrapper.print("Syntax check on IBGP_PEER_TEMPLATE %s" % IBGP_PEER_TEMPLATE)
        if IBGP_PEER_TEMPLATE:
            bgp_peer_template = IBGP_PEER_TEMPLATE.splitlines()
            Wrapper.print("bgp_peer_template %s" % bgp_peer_template)
            remote_as_present, af_evpn_present, af_mvpn_present, errorMsg = False, False, False, ""

            errCmd = ""
            for index, cmd in enumerate(bgp_peer_template):
                if index == 0:
                    if not cmd.startswith("  ") or cmd[2] == " ":
                        errorMsg += "iBGP peer template: bgp peer template command must have 2 leading spaces. Please fix spacing problem: %s. " % cmd
                elif not cmd.startswith("    "):
                    errCmd += ("[%s] " % cmd)
            if errCmd != "":
                errorMsg += "iBGP peer template: bgp peer template sub-command must have 4 or 6 leading spaces. Please fix spacing problem in the following commands: %s. " % errCmd

            if not bgp_peer_template[0].strip().startswith('template peer') and not bgp_peer_template[0].strip().startswith('template peer-session'):
                errorMsg += "iBGP peer template: peer template needs to start with '  template peer' or '  template peer-session'. "
            else:
                peer_cmd = bgp_peer_template[0].strip().split(" ")
                if len(peer_cmd) != 3:
                    errorMsg += "iBGP peer template: command '%s' has invalid syntax. " % bgp_peer_template[0]

            for index, line in enumerate(bgp_peer_template, start=1):
                if line.strip().startswith('remote-as'):
                    remote_as_present = True
                    if not line.startswith("    re"):
                        errorMsg += "iBGP peer template: remote-as command must start with 4 leading spaces. Please fix spacing problem:%s. " % line
                    as_cmd = line.strip().split(' ')
                    if len(as_cmd) == 2:
                        if as_cmd[1] != BGP_AS:
                            errorMsg += "iBGP peer template: remote ASN %s does not match fabric BGP ASN %s. " % (as_cmd[1], BGP_AS)
                    else:
                        errorMsg += "iBGP peer template: '%s' command with invalid syntax. " % line
                elif line.strip() == 'address-family l2vpn evpn':
                    af_evpn_present = True
                    if not line.startswith("    a"):
                        errorMsg += "iBGP peer template: address-family command must start with 4 leading spaces. Please fix spacing problem:%s. " % line
                elif line.strip() == 'address-family ipv4 mvpn':
                    af_mvpn_present = True
                    if not line.startswith("    a"):
                        errorMsg += "iBGP peer template: address-family command must start with 4 leading spaces. Please fix spacing problem:%s. " % line

            if not remote_as_present:
                errorMsg += "iBGP peer template: missing 'remote-as' command. "
            if not af_evpn_present:
                errorMsg += "iBGP peer template: missing 'address-family l2vpn evpn' command. "
            if ENABLE_TRM == "true" and not af_mvpn_present:
                errorMsg += "iBGP peer template: missing 'address-family ipv4 mvpn' command. "
            if ENABLE_TRM != "true" and af_mvpn_present:
                errorMsg += "iBGP peer template: 'address-family ipv4 mvpn' present while Tenant Routed Multicast is not enabled. "

            if errorMsg:
                respObj.addErrorReport(funcName, errorMsg)
                respObj.setFailureRetCode()
                return respObj

        Wrapper.print("Syntax check on IBGP_PEER_TEMPLATE_LEAF %s" % IBGP_PEER_TEMPLATE_LEAF)
        if IBGP_PEER_TEMPLATE_LEAF:
            if not IBGP_PEER_TEMPLATE:
                errorMsg = "Please fill the iBGP peer template field when Leaf/Border/Border Gateway iBGP peer template is non empty. "
                respObj.addErrorReport(funcName, errorMsg)
                respObj.setFailureRetCode()
                return respObj

            bgp_peer_template = IBGP_PEER_TEMPLATE_LEAF.splitlines()
            Wrapper.print("leaf bgp_peer_template %s" % bgp_peer_template)
            remote_as_present, af_evpn_present, af_mvpn_present, rr_client_present, errorMsg = False, False, False, False, ""

            errCmd = ""
            for index, cmd in enumerate(bgp_peer_template):
                if index == 0:
                    if not cmd.startswith("  ") or cmd[2] == " ":
                        errorMsg += "Leaf iBGP peer template: bgp peer template command must have 2 leading spaces. Please fix spacing problem: %s. " % cmd
                elif not cmd.startswith("    "):
                    errCmd += ("[%s] " % cmd)
            if errCmd != "":
                errorMsg += "Leaf iBGP peer template: bgp peer template sub-command must have 4 or 6 leading spaces. Please fix spacing problem in the following commands: %s. " % errCmd

            if not bgp_peer_template[0].strip().startswith('template peer') and not bgp_peer_template[0].strip().startswith('template peer-session'):
                errorMsg += "Leaf iBGP peer template: peer template needs to start with '  template peer' or '  template peer-session'. "
            else:
                peer_cmd = bgp_peer_template[0].strip().split(" ")
                if len(peer_cmd) != 3:
                    errorMsg += "Leaf iBGP peer template: command '%s' has invalid syntax. " % bgp_peer_template[0]

            for index, line in enumerate(bgp_peer_template, start=1):
                if line.strip().startswith('route-reflector-client'):
                    rr_client_present = True

                if line.strip().startswith('remote-as'):
                    remote_as_present = True
                    if not line.startswith("    r"):
                        errorMsg += "Leaf iBGP peer template: remote-as command must start with 4 leading spaces. Please fix spacing problem:%s. " % line
                    as_cmd = line.strip().split(' ')
                    if len(as_cmd) == 2:
                        if as_cmd[1] != BGP_AS:
                            errorMsg += "Leaf iBGP peer template: remote ASN %s does not match fabric BGP ASN %s. " % (as_cmd[1], BGP_AS)
                    else:
                        errorMsg += "Leaf iBGP peer template: '%s' command with invalid syntax. " % line
                elif line.strip() == 'address-family l2vpn evpn':
                    af_evpn_present = True
                    if not line.startswith("    a"):
                        errorMsg += "Leaf iBGP peer template: address-family command must start with 4 leading spaces. Please fix spacing problem:%s. " % line
                elif line.strip() == 'address-family ipv4 mvpn':
                    af_mvpn_present = True
                    if not line.startswith("    a"):
                        errorMsg += "Leaf iBGP peer template: address-family command must start with 4 leading spaces. Please fix spacing problem:%s. " % line

            if rr_client_present:
                errorMsg += "Leaf iBGP peer template should not contain 'route-reflector-client' command. "
            if not remote_as_present:
                errorMsg += "Leaf iBGP peer template: missing 'remote-as' command. "
            if not af_evpn_present:
                errorMsg += "Leaf iBGP peer template: missing 'address-family l2vpn evpn' command. "
            if ENABLE_TRM == "true" and not af_mvpn_present:
                errorMsg += "Leaf iBGP peer template: missing 'address-family ipv4 mvpn' command. "
            if ENABLE_TRM != "true" and af_mvpn_present:
                errorMsg += "Leaf iBGP peer template: 'address-family ipv4 mvpn' present while Tenant Routed Multicast is not enabled. "

            if errorMsg:
                respObj.addErrorReport(funcName, errorMsg)
                respObj.setFailureRetCode()
                return respObj

        if UNDERLAY_IS_V6 != UNDERLAY_IS_V6_PREV and UNDERLAY_IS_V6_PREV != "":
            overlayPresent = Util.exe(Helper.isOverlayExist(FABRIC_NAME))
            if overlayPresent:
                # cannot allow this change because the vrf/network mcast underlay address is per underlay IP version
                respObj.addErrorReport(funcName,
                    "'Enable IPv6 Underlay' cannot be changed from [%s] to [%s] with existing overlay config." %
                    (UNDERLAY_IS_V6_PREV, UNDERLAY_IS_V6))
                respObj.setFailureRetCode()
                return respObj

        if not checkFabricMtuSettings(respObj):
            return respObj

        if not checkFabricVpcDomainId(respObj):
            return respObj

        if not checkBgpAsChange(respObj):
            return respObj

        if not checkUnderlayProtocolChange(respObj):
            return respObj

        if not checkLinkProtocolTagChange(respObj):
            return respObj

        if not checkOverlayModeChange(respObj):
            return respObj

        if not macSecSanityCheck(respObj):
            return respObj

        if not DCImacSecSanityCheck(respObj):
            return respObj

        enableMacSecPrev = fabricSettings.get("ENABLE_MACSEC_PREV", "false")
        if not disableMACsecAllowed(respObj, enableMacSecPrev):
            return respObj

        enableDCIMacSecPrev = fabricSettings.get("ENABLE_DCI_MACSEC_PREV", "false")
        if not disableDCIMACsecAllowed(respObj, enableDCIMacSecPrev):
            return respObj

        qkdProfileNamePrev = fabricSettings.get("QKD_PROFILE_NAME_PREV", "")
        if not changeDCIQKDAllowed(respObj, qkdProfileNamePrev):
            return respObj

        if ENABLE_AGG_ACC_ID_RANGE == "true":
            userList = Util.getIntegerRange(AGG_ACC_VPC_PO_ID_RANGE)
            if VPC_PEER_LINK_PO != "" and int(VPC_PEER_LINK_PO) in userList:
                errMsg = ("vPC Peer Link Port Channel ID (%s) set in fabric settings cannot be in the "
                          "vPC/Port-Channel ID range (%s) used for leaf-tor pairings. "
                          "Please update the range or change vPC Peer Link Port Channel ID." %
                          (VPC_PEER_LINK_PO, AGG_ACC_VPC_PO_ID_RANGE))
                respObj.addErrorReport(funcName, errMsg)
                respObj.setFailureRetCode()
                return respObj

        # check loopback resource range
        if STATIC_UNDERLAY_IP_ALLOC != "true":
            if UNDERLAY_IS_V6 != "true":
                ip0, mask0 = LOOPBACK0_IP_RANGE.split("/")
                ip1, mask1 = LOOPBACK1_IP_RANGE.split("/")
                if mask0 == "32" or mask1 == "32":
                    errMsg = "Underlay Routing or VTEP Loopback IP Range Mask has to be smaller than 32. "
                    respObj.addErrorReport(funcName, errMsg)
                    respObj.setFailureRetCode()
                if MPLS_HANDOFF == "true":
                    ip, mask = MPLS_LOOPBACK_IP_RANGE.split("/")
                    if mask == "32":
                        errMsg = "MPLS Loopback IP Range Mask has to be smaller than 32. "
                        respObj.addErrorReport(funcName, errMsg)
                        respObj.setFailureRetCode()
            else:
                ip0, mask0 = LOOPBACK0_IPV6_RANGE.split("/")
                ip1, mask1 = LOOPBACK1_IPV6_RANGE.split("/")
                if mask0 == "128" or mask1 == "128":
                    errMsg = "Underlay Loopback IPV6 Range Mask has to be smaller than 128."
                    respObj.addErrorReport(funcName, errMsg)
                    respObj.setFailureRetCode()

            if respObj.isRetCodeFailure():
                return respObj

        dynamicIPPoolsEnable = True
        try:
            if STATIC_UNDERLAY_IP_ALLOC == "true":
                dynamicIPPoolsEnable = False
        except:
            pass

        # Initialization of resource manager for Underlay Resources.
        if dynamicIPPoolsEnable:
            dictObj = {"FABRIC_NAME" : FABRIC_NAME}
            newRespObj = PTI.executePyTemplateMethod("Easy_Fabric_Extn_11_1", dictObj, "checkIfDuplicatePools")
            Util.processRespObj(respObj, newRespObj)
            if UNDERLAY_IS_V6 != "true":
                Util.exe(RM.addOrUpdatePoolData(FABRIC_NAME, PoolName.SUBNET, PoolType.SUBNET, SUBNET_RANGE, SUBNET_TARGET_MASK))
                Util.exe(RM.addOrUpdatePoolData(FABRIC_NAME, "LOOPBACK0_IP_POOL", PoolType.IP, LOOPBACK0_IP_RANGE))
                Util.exe(RM.addOrUpdatePoolData(FABRIC_NAME, "LOOPBACK1_IP_POOL", PoolType.IP, LOOPBACK1_IP_RANGE))

                # special processing for Inband POAP and unnumbered fabric
                if inbandPOAPEnable == "true" and FABRIC_INTERFACE_TYPE != "p2p":
                    #   - set RM with the anycast IP for the POAP default GW (the first IP in the range)
                    lb0NwkAddr = LOOPBACK0_IP_RANGE.split("/")[0]
                    lb0NwkPrefix = LOOPBACK0_IP_RANGE.split("/")[1]

                    #Pick first address in loopback0 ip range as the default gw for the DHCP subnet scope programming
                    lb0NwkBytes = lb0NwkAddr.split(".")
                    lb0NwkGwLastByte = int(lb0NwkBytes[3]) + 1
                    dhcpUnnumGwIp = lb0NwkBytes[0] + "." + lb0NwkBytes[1] + "." + lb0NwkBytes[2] + "." + str(lb0NwkGwLastByte)

                    Wrapper.print("%s: FAB [%s]: dhcpUnnumGwIp [%r]" % (funcName, FABRIC_NAME, dhcpUnnumGwIp))
                    # reserve this in RM for DHCP code to use
                    Util.exeRM(RM.set(FABRIC_NAME, "LOOPBACK0_IP_POOL", EntityType.FABRIC, "INBAND_POAP_GW", dhcpUnnumGwIp))

                ip, mask = ANYCAST_RP_IP_RANGE.split("/") if ANYCAST_RP_IP_RANGE else ("","")
                if mask == "32":
                    Util.exe(RM.addOrUpdateEmptyPool(FABRIC_NAME, "ANYCAST_RP_IP_POOL", PoolType.IP))
                else:
                    Util.exe(RM.addOrUpdatePoolData(FABRIC_NAME, "ANYCAST_RP_IP_POOL", PoolType.IP, ANYCAST_RP_IP_RANGE))

                if MPLS_HANDOFF == "true":
                    Util.exe(RM.addOrUpdatePoolData(FABRIC_NAME, "MPLS_LOOPBACK_IP_POOL", PoolType.IP, MPLS_LOOPBACK_IP_RANGE))
                else:
                    Util.exe(RM.addOrUpdateEmptyPool(FABRIC_NAME, "MPLS_LOOPBACK_IP_POOL", PoolType.IP))
            else:
                if USE_LINK_LOCAL == "false":
                    Util.exe(RM.addOrUpdatePoolData(FABRIC_NAME, PoolName.SUBNET, PoolType.SUBNET, V6_SUBNET_RANGE, V6_SUBNET_TARGET_MASK))
                else:
                    Util.exe(RM.addOrUpdateEmptyPool(FABRIC_NAME, PoolName.SUBNET, PoolType.SUBNET))
                Util.exe(RM.addOrUpdatePoolData(FABRIC_NAME, "LOOPBACK0_IP_POOL", PoolType.IP, LOOPBACK0_IPV6_RANGE))
                Util.exe(RM.addOrUpdatePoolData(FABRIC_NAME, "LOOPBACK1_IP_POOL", PoolType.IP, LOOPBACK1_IPV6_RANGE))
                Util.exe(RM.addOrUpdatePoolData(FABRIC_NAME, "ROUTER_ID_POOL", PoolType.IP, ROUTER_ID_RANGE))
                if REPLICATION_MODE == "Multicast":
                    ip, mask = IPv6_ANYCAST_RP_IP_RANGE.split("/") if IPv6_ANYCAST_RP_IP_RANGE else ("","")
                    if mask == "128":
                        Util.exe(RM.addOrUpdateEmptyPool(FABRIC_NAME, "ANYCAST_RP_IP_POOL", PoolType.IP))
                    else:
                        Util.exe(RM.addOrUpdatePoolData(FABRIC_NAME, "ANYCAST_RP_IP_POOL", PoolType.IP, IPv6_ANYCAST_RP_IP_RANGE))
        else:
            # init IP pools to be empty. The IP addresses are expected to be explicitly set in RM offline
            Wrapper.print("fabricInit: Init Empty Subnet Pool - PoolName.SUBNET")
            Util.exe(RM.addOrUpdateEmptyPool(FABRIC_NAME, PoolName.SUBNET, PoolType.SUBNET))
            Wrapper.print("fabricInit: Init Empty IP Pool - LOOPBACK0_IP_POOL")
            Util.exe(RM.addOrUpdateEmptyPool(FABRIC_NAME, "LOOPBACK0_IP_POOL", PoolType.IP))
            Wrapper.print("fabricInit: Init Empty IP Pool - LOOPBACK1_IP_POOL")
            Util.exe(RM.addOrUpdateEmptyPool(FABRIC_NAME, "LOOPBACK1_IP_POOL", PoolType.IP))
            if UNDERLAY_IS_V6 != "true":
                Wrapper.print("fabricInit: Init Empty IP Pool - ANYCAST_RP_IP_POOL")
                Util.exe(RM.addOrUpdateEmptyPool(FABRIC_NAME, "ANYCAST_RP_IP_POOL", PoolType.IP))
                if MPLS_HANDOFF == "true":
                    Wrapper.print("fabricInit: Init Empty IP Pool - MPLS_LOOPBACK_IP_POOL")
                    Util.exe(RM.addOrUpdateEmptyPool(FABRIC_NAME, "MPLS_LOOPBACK_IP_POOL", PoolType.IP))
            else:
                Wrapper.print("fabricInit: Init Empty IP Pool - ROUTER_ID_POOL")
                Util.exe(RM.addOrUpdateEmptyPool(FABRIC_NAME, "ROUTER_ID_POOL", PoolType.IP))
                Util.exe(RM.addOrUpdateEmptyPool(FABRIC_NAME, "ANYCAST_RP_IP_POOL", PoolType.IP))

        if DCI_SUBNET_RANGE != "":
            Util.exe(RM.addOrUpdatePoolData(FABRIC_NAME, "DCI subnet pool",
                                            PoolType.SUBNET, DCI_SUBNET_RANGE,
                                            DCI_SUBNET_TARGET_MASK))
        else:
            Util.exe(RM.addOrUpdateEmptyPool(FABRIC_NAME, "DCI subnet pool",
                                             PoolType.SUBNET))
            Wrapper.print("Empty DCI Subnet range, ignore")
        # Initialize an empty DCI subnet pool for IPv6
        Util.exe(RM.addOrUpdateEmptyPool(FABRIC_NAME, "IPv6 DCI subnet pool", PoolType.SUBNET))
        Wrapper.print("Empty IPv6 DCI Subnet range, ignore")

        # Initialization of resource manager for Overlay and Underlay Resources (port-channel and other IDs).
        # PC ID pool should be 1-499, 501-4096 once RM get/set is working with range.
        # 500 is default for underlay - vpc peer link port-channel and vpc id
        Util.exe(RM.addOrUpdatePoolData(FABRIC_NAME, "PORT_CHANNEL_ID", "501-4000"))
        Util.exe(RM.addOrUpdatePoolData(FABRIC_NAME, "FEX_ID", "101-199"))

        Util.exe(RM.addOrUpdatePoolData(FABRIC_NAME, "VPC_ID", "1-100, 200-499"))
        Util.exe(RM.addOrUpdatePoolData(FABRIC_NAME, "VPC_DOMAIN_ID", VPC_DOMAIN_ID_RANGE))
        if ENABLE_AGG_ACC_ID_RANGE == "true":
            userList = Util.getIntegerRange(AGG_ACC_VPC_PO_ID_RANGE)
            defaultList = Util.getIntegerRange("501-4000")
            combinedList = userList + defaultList
            finalList = []
            for number in combinedList:
                if number not in finalList:
                    finalList.append(number)
            finalRange = Util.strRangeFromNumList(finalList)
            Util.exe(RM.addOrUpdatePoolData(FABRIC_NAME, "PORT_CHANNEL_ID", finalRange))
            Wrapper.print("%s: final PORT_CHANNEL_ID pool range [%s]" % (funcName, finalRange))

            defaultList = Util.getIntegerRange("1-100, 200-499")
            combinedList = userList + defaultList
            finalList = []
            for number in combinedList:
                if number not in finalList:
                    finalList.append(number)
            finalRange = Util.strRangeFromNumList(finalList)
            Util.exe(RM.addOrUpdatePoolData(FABRIC_NAME, "VPC_ID", finalRange))
            Wrapper.print("%s: final VPC_ID pool range [%s]" % (funcName, finalRange))
        Util.exe(RM.addOrUpdatePoolData(FABRIC_NAME, "VPC_PEER_LINK_VLAN", VPC_PEER_LINK_VLAN))

        # Loopback pool should be 2-199, 201-1000 once RM get/set is working with range.
        # 0,1,254,255 reserved for underlay - bgp, nve, border gateway, anycast rp loopbacks
        Util.exe(RM.addOrUpdatePoolData(FABRIC_NAME, "LOOPBACK_ID", "0-1023"))

        # Initialization of resource manager for Overlay Resources.
        Util.exe(RM.addOrUpdatePoolData(FABRIC_NAME, "TOP_DOWN_L3_DOT1Q", SUBINTERFACE_RANGE))
        Util.exe(RM.addOrUpdatePoolData(FABRIC_NAME, "TOP_DOWN_NETWORK_VLAN", NETWORK_VLAN_RANGE))
        Util.exe(RM.addOrUpdatePoolData(FABRIC_NAME, "TOP_DOWN_VRF_VLAN", VRF_VLAN_RANGE))

        Util.exe(RM.addOrUpdatePoolData(FABRIC_NAME, "BGP_ASN_ID", PoolType.ID, BGP_AS))
        Util.exe(RM.addOrUpdatePoolData(FABRIC_NAME, "L3_VNI", L3_PARTITION_ID_RANGE))
        Util.exe(RM.addOrUpdatePoolData(FABRIC_NAME, "L2_VNI", L2_SEGMENT_ID_RANGE))
        if UNDERLAY_IS_V6 != "true":
            Util.exe(RM.addOrUpdateOverlapPool(FABRIC_NAME, "MCAST_IP_POOL", PoolType.IP, MULTICAST_GROUP_SUBNET))
        else:
            Util.exe(RM.addOrUpdateOverlapPool(FABRIC_NAME, "MCAST_IP_POOL", PoolType.IP, IPv6_MULTICAST_GROUP_SUBNET))

        if (ENABLE_TRM == "true" or ENABLE_TRMv6 == "true") and (UNDERLAY_IS_V6 == "true" or ALLOW_L3VNI_NO_VLAN == "true"):
            if MVPN_VRI_ID_RANGE == "":
                fabricId = AppUtil.getFabricId(FABRIC_NAME)
                startingRange = fabricId%64
                if (startingRange == 0):
                    vriRange = "1-999"
                else:
                    vriRange = str(startingRange) + "000-" + str(startingRange) + "999"

                FabricWrapper.update(FABRIC_NAME,"MVPN_VRI_ID_RANGE", vriRange)
                Wrapper.print("%s[%s] fabricId %s, vriRange %s"%(funcName, FABRIC_NAME, fabricId, vriRange))
            else:
                vriRange = MVPN_VRI_ID_RANGE
            Util.exe(RM.addOrUpdatePoolData(FABRIC_NAME, "MVPN_VRI_ID", vriRange))

        # always have the relevant pool as user may define the policies before enabling PBR flag
        Util.exe(RM.addOrUpdatePoolData(FABRIC_NAME, "SERVICE_NETWORK_VLAN", SERVICE_NETWORK_VLAN_RANGE))
        Util.exe(RM.addOrUpdatePoolData(FABRIC_NAME, "ROUTE_MAP_SEQUENCE_NUMBER_POOL", ROUTE_MAP_SEQUENCE_NUMBER_RANGE))
        Util.exe(RM.addOrUpdatePoolData(FABRIC_NAME, "SLA_ID", SLA_ID_RANGE))
        Util.exe(RM.addOrUpdatePoolData(FABRIC_NAME, "OBJECT_TRACKING_NUMBER_POOL", OBJECT_TRACKING_NUMBER_RANGE))

        # Validate additional settings
        dict["FABRIC_VALIDATION_PARAMS"] = {"validateManagebilitySettings": True,
                                            "validateNetflowSettings" : True,
                                            "validatePvlanSettings": True,
                                            "validateNxCloudSettings": True,
                                            "validateSGTSettings": ENABLE_SGT == "true",
                                            "validateLanDeviceConnectivityMode" : True,
                                            "validateL3vniMode": True}
        dict["FABRIC_INIT"] = True
        Util.exe(PTI.executePyTemplateMethod("fabric_utility_11_1", dict, "validateInitFabricSettings"))

        Util.processRespObj(respObj, PTI.executePyTemplateMethod("fabric_utility_11_1", dict, "siteIdTracking"))
        if respObj.isRetCodeFailure():
            return respObj

        # validation passes. Update if applicable
        if ENABLE_PVLAN_PREV != ENABLE_PVLAN:
            Util.exe(FabricWrapper.update(FABRIC_NAME, "ENABLE_PVLAN_PREV", ENABLE_PVLAN))

        if ALLOW_L3VNI_NO_VLAN != ALLOW_L3VNI_NO_VLAN_PREV:
            Util.exe(FabricWrapper.update(FABRIC_NAME, "ALLOW_L3VNI_NO_VLAN_PREV", ALLOW_L3VNI_NO_VLAN))

        if UNDERLAY_IS_V6 != UNDERLAY_IS_V6_PREV:
            Util.exe(FabricWrapper.update(FABRIC_NAME, "UNDERLAY_IS_V6_PREV", UNDERLAY_IS_V6))

        if ENABLE_SGT == "true":
            Util.exe(RM.addOrUpdatePoolData(FABRIC_NAME, "SGT_ID", SGT_ID_RANGE))

        enableMacSec = fabricSettings.get("ENABLE_MACSEC")
        enableMacSecPrev = fabricSettings.get("ENABLE_MACSEC_PREV", "false")
        if enableMacSecPrev != enableMacSec:
            Util.exe(FabricWrapper.update(FABRIC_NAME, "ENABLE_MACSEC_PREV", enableMacSec))

        enableDCIMacSec = fabricSettings.get("ENABLE_DCI_MACSEC", "false")
        enableDCIMacSecPrev = fabricSettings.get("ENABLE_DCI_MACSEC_PREV", "false")
        if enableDCIMacSecPrev != enableDCIMacSec:
            Util.exe(FabricWrapper.update(FABRIC_NAME, "ENABLE_DCI_MACSEC_PREV", enableDCIMacSec))

        qkdProfileName = fabricSettings.get("QKD_PROFILE_NAME", "").strip()
        qkdProfileNamePrev = fabricSettings.get("QKD_PROFILE_NAME_PREV", "")
        if qkdProfileNamePrev != qkdProfileName:
            Util.exe(FabricWrapper.update(FABRIC_NAME, "QKD_PROFILE_NAME_PREV", qkdProfileName))

        allowNxc = fabricSettings.get("ALLOW_NXC", "false")
        allowNxcPrev = fabricSettings.get("ALLOW_NXC_PREV", "false")
        if allowNxcPrev != allowNxc:
            Util.exe(FabricWrapper.update(FABRIC_NAME, "ALLOW_NXC_PREV", allowNxc))

        if (AUTO_UNIQUE_VRF_LITE_IP_PREFIX != "true" and
            AUTO_UNIQUE_VRF_LITE_IP_PREFIX_PREV != "true" and
            PER_VRF_LOOPBACK_AUTO_PROVISION != "true" and
            PER_VRF_LOOPBACK_AUTO_PROVISION_PREV != "true" and
            PER_VRF_LOOPBACK_AUTO_PROVISION_V6 != "true" and
            PER_VRF_LOOPBACK_AUTO_PROVISION_V6_PREV != "true" and
            TOPDOWN_CONFIG_RM_TRACKING != "completed"):
            Util.exe(FabricWrapper.update(FABRIC_NAME, "TOPDOWN_CONFIG_RM_TRACKING", "notstarted"))

        autoVrfLiteUniqIp = fabricSettings.get("AUTO_UNIQUE_VRF_LITE_IP_PREFIX", "false")
        autoVrfLiteUniqIpPrev = fabricSettings.get("AUTO_UNIQUE_VRF_LITE_IP_PREFIX_PREV", "false")
        if autoVrfLiteUniqIpPrev != autoVrfLiteUniqIp:
            Util.exe(FabricWrapper.update(FABRIC_NAME, "AUTO_UNIQUE_VRF_LITE_IP_PREFIX_PREV", autoVrfLiteUniqIp))
            if TOPDOWN_CONFIG_RM_TRACKING == "completed" and autoVrfLiteUniqIp == "true":
                Util.exe(FabricWrapper.update(FABRIC_NAME, "TOPDOWN_CONFIG_RM_TRACKING", "restart"))

        pervrfLbProv = fabricSettings.get("PER_VRF_LOOPBACK_AUTO_PROVISION", "false")
        pervrfLbProvPrev = fabricSettings.get("PER_VRF_LOOPBACK_AUTO_PROVISION_PREV", "false")

        pervrfLb6Prov = fabricSettings.get("PER_VRF_LOOPBACK_AUTO_PROVISION_V6", "false")
        pervrfLb6ProvPrev = fabricSettings.get("PER_VRF_LOOPBACK_AUTO_PROVISION_V6_PREV", "false")

        if pervrfLbProvPrev != pervrfLbProv:
            Util.exe(FabricWrapper.update(FABRIC_NAME, "PER_VRF_LOOPBACK_AUTO_PROVISION_PREV", pervrfLbProv))

        if pervrfLb6ProvPrev != pervrfLb6Prov:
            Util.exe(FabricWrapper.update(FABRIC_NAME, "PER_VRF_LOOPBACK_AUTO_PROVISION_V6_PREV", pervrfLb6Prov))


        # dhcp initialization for DHCP IPs provided in bootstrap section.
        dict = getGlobals(dictionaryObj)
        Util.exe(dhcpInit(dict))

        Util.exe(BRW.CreateBackUpJob(FABRIC_NAME, enableRealTimeBackup, enableScheduledBackup, scheduledTime))
    except Exception as e:
        Wrapper.print("==========Exception in %s: FAB [%s]" % (funcName, FABRIC_NAME))
        if isinstance(e, respObjError):
            Util.processRespObj(respObj, e.value)
        else:
            Util.handleException("Unexpected error creating fabric", e, respObj)
    finally:
        Wrapper.print("==========ACTION: FAB [%s]: Finish: %s: Success = [%r]" %
                (FABRIC_NAME, funcName, respObj.isRetCodeSuccess()))
    return respObj

#initialize DHCP scope in dchp.conf for bootstrapped devices for automatic IP assignments
def dhcpInit(dictionaryObj):
    funcName = sys._getframe(0).f_code.co_name
    Wrapper.print("==========ACTION: FAB [%s]: Start: %s" % (FABRIC_NAME, funcName))
    respObj = WrappersResp.getRespObj()
    respObj.setSuccessRetCode()
    try:
        respObj = PTI.executePyTemplateMethod("dhcp_common", getGlobals(dictionaryObj), "dhcpInit")
    except respObjError as e:
        respObj = e.value
    finally:
        Wrapper.print("==========ACTION: FAB [%s]: Finish: %s: Success = [%r]" % \
                    (FABRIC_NAME, funcName, respObj.isRetCodeSuccess()))
    return respObj

def getFabErrEntity(fnName, entityName=None):
    if entityName:
        return fnName + ":" + entityName
    else:
        return fnName

def getStrGlobals():
    newDict = {}
    gDict = globals()
    for key in gDict.keys():
        if type(gDict[key]) is str:
            newDict[key] = gDict[key]
    return newDict

def actionAllow():
    Wrapper.print("actionAllow: FAB [%s]: FF [%s]" % (FABRIC_NAME, FF))
    r = WrappersResp.getRespObj()
    r.setSuccessRetCode()
    try:
        extFabricType = EXT_FABRIC_TYPE
    except:
        extFabricType = ""

    if FF != "Easy_Fabric":
        fabricType = Util.mapFFToFabricType(FF, extFabricType)
        article = "An" if fabricType[0].lower() in ['a','e','i','o','u'] else "A"
        r.addErrorReport("actionAllow", "%s %s fabric may not be converted to a Data Center VXLAN EVPN fabric "
                         "as that may cause configuration issues. Please revert the fabric to %s and save." %
                         (article, fabricType, fabricType))
        r.setFailureRetCode()
    return r

def preAdd(dictionaryObj):
    Wrapper.print("==========ACTION: FAB [%s]: Start: preAdd: Serial [%s]" %
        (FABRIC_NAME, dictionaryObj["deviceSerial"]))
    respObj = WrappersResp.getRespObj()
    respObj.setSuccessRetCode()
    try:
        # need to allocate below new object using wrapper to return response of success/failure to GUI.
        # by default below API sets retCode to SUCCESS
        Util.exe(actionAllow())

        Wrapper.print("==========preAdd: Fabric Name = %s, keys = %d, Device Serial = %s, Device Model = %s, Preserve Config = %s" %
                      (FABRIC_NAME, len(dictionaryObj), dictionaryObj["deviceSerial"],  dictionaryObj["deviceModel"],
                       dictionaryObj["devicePreserveConfig"]))
        dict = getGlobals(dictionaryObj)
        respObj = Util.exe(PTI.executePyTemplateMethod("fabric_upgrade_11_1", dict, "preAddExt"))

    except respObjError as e:
        respObj = e.value
    finally:
        Wrapper.print("==========ACTION: FAB [%s]: Finish: preAdd: Serial [%s]. Success = [%r]" %
                (FABRIC_NAME, dictionaryObj["deviceSerial"], respObj.isRetCodeSuccess()))
        return respObj

def getGlobals(additionalDict=None):
    newDict = {}
    gDict = globals()
    for key in gDict.keys():
        if ((type(gDict[key]) is str) or
            (type(gDict[key]) is dict)):
            newDict[key] = gDict[key]
    if additionalDict:
        newDict.update(additionalDict)
    return newDict

def preChangeDiscoveryIP(dictionaryObj):
    funcName = sys._getframe(0).f_code.co_name
    Wrapper.print("==========ACTION: FAB [%s]: Start: %s" % (FABRIC_NAME, funcName))
    respObj = WrappersResp.getRespObj()
    respObj.setSuccessRetCode()
    Util.exe(actionAllow())
    try:
        dict = getGlobals(dictionaryObj)
        respObj = PTI.executePyTemplateMethod("fabric_upgrade_11_1", dict, "doPreChangeDiscoveryIP")
    except Exception as e:
        msg = ("Unexpected error during change discovery IP handling")
        if isinstance(e, respObjError):
            respObj.addErrorReport(getFabErrEntity(funcName), msg)
            respObj.setFailureRetCode()
            Util.processRespObj(respObj, e.value)
        else:
            Util.handleException(msg, e, respObj)
    finally:
        Wrapper.print("==========ACTION: FAB [%s]: Finish: %s: Success = [%r]" % (FABRIC_NAME, funcName, respObj.isRetCodeSuccess()))
        return respObj

def postAdd(dictionaryObj):
    Wrapper.print("==========ACTION: FAB [%s]: Start: postAdd: Serial [%s] dictionaryObj %s" %
            (FABRIC_NAME, dictionaryObj["deviceSerial"], dictionaryObj))
    respObj = WrappersResp.getRespObj()
    respObj.setSuccessRetCode()
    try:
        dict = getGlobals(dictionaryObj)
        respObj = Util.exe(PTI.executePyTemplateMethod("fabric_upgrade_11_1", dict, "postAddExt"))
        return respObj
    except respObjError as e:
        respObj = e.value
        return respObj
    finally:
        Wrapper.print("==========ACTION: FAB [%s]: Finish: postAdd: Serial [%s]. Success = [%r]" %
                (FABRIC_NAME, dictionaryObj["deviceSerial"], respObj.isRetCodeSuccess()))

def getIntegerRange(rangeStr):
    return sum(((list(range(*[int(j) + k for k,j in enumerate(i.split('-'))]))
                        if '-' in i else [int(i)]) for i in rangeStr.split(',')), [])

def bootstrapDevice(dictionaryObj):
    funcName = sys._getframe(0).f_code.co_name
    Wrapper.print("==========ACTION: FAB [%s]: Start: %s, dictionaryObj %s" % (FABRIC_NAME, funcName, str(dictionaryObj)))
    respObj = WrappersResp.getRespObj()
    respObj.setSuccessRetCode()
    try:
        Util.exe(actionAllow())
        dict = getGlobals(dictionaryObj)
        devices = dictionaryObj["bootstrapDevices"]
        numDevicesToBootstrap = len(devices)
        fabricSettings = Util.exe(FabricWrapper.get(FABRIC_NAME)).getNvPairs()
        dcnmUser = fabricSettings.get("dcnmUser", "")
        inbandPOAPEnable = isInbandPoapEnabled(fabricSettings)
        Wrapper.print("%s: Fabric [%s]: inbandPOAPEnable [%s] dcnmUser [%s] Num devices [%d]" % (funcName, 
                        FABRIC_NAME, inbandPOAPEnable, dcnmUser, numDevicesToBootstrap))

        for i in range(numDevicesToBootstrap):
            Wrapper.print("Fabric [%s]: Attempting Bootstrap for Switch [%s] - #%d of %d" %(FABRIC_NAME,
                                        devices[i].serialNumber, i+1, numDevicesToBootstrap))

        # Wrapper.print("%s: Sending dictionary obj %s for fabric %s" %(funcName, FABRIC_NAME, str(dict)))
        newRespObj = PTI.executePyTemplateMethod("dhcp_common", dict, "bootstrapDevice")
        processRespObj(respObj, newRespObj)
        if inbandPOAPEnable == "true":
            if newRespObj.isRetCodeFailure():
                # bootstrap for some switches failed... log them here. Fabric errors must already be present from earlier call
                failedSwitchSerials = newRespObj.getValue()
                numDevices = len(failedSwitchSerials)
                i = 0
                for serial in failedSwitchSerials:
                    Wrapper.print("Fabric [%s]: Bootstrap failed for Switch [%s] - #%d of %d" % (FABRIC_NAME, serial, ++i, numDevices))

                devicesToContinue = []
                for i in range(numDevicesToBootstrap):
                    if devices[i].serialNumber not in failedSwitchSerials:
                        devicesToContinue.append(copy.deepcopy(devices[i]))
            else:
                devicesToContinue = devices

            if len(devicesToContinue):
                dictionaryObj["bootstrapDevices"] = devicesToContinue
                # Additional processing for inband POAP
                #Should call configSave to generate the full startup config of the switch being bootstrapped
                processRespObj(respObj, configSaveInband(dict))
    except respObjError as e:
        respObj = e.value
    finally:
        Wrapper.print("==========ACTION: FAB [%s]: Finish: %s: Success = [%r]" % (FABRIC_NAME, 
                                                            funcName, respObj.isRetCodeSuccess()))
    return respObj

def preFabricDelete(dictionaryObj):
    Wrapper.print("==========ACTION: FAB [%s]: Start: preFabricDelete" % (FABRIC_NAME))
    respObj = WrappersResp.getRespObj()
    respObj.setSuccessRetCode()
    #check switches
    try:
        Util.exe(actionAllow())
        topologyDataObj = TopologyData(Util.exe(TopologyWrapper.get(FABRIC_NAME)))
        devices = topologyDataObj.get(TopologyInfoType.SWITCHES)  # all devices serial number
        devices = filter(None, devices)
        Wrapper.print("PFD: Found %d Switches" % len(devices))
        if (len(devices) > 0):
            respObj.addErrorReport(getFabErrEntity(preFabricDelete.__name__),
                                   "Fabric cannot be deleted with switches present. "
                                   "Please check the Switches page to make sure "
                                   "there are no switch entries and retry.")
            respObj.setFailureRetCode()
            return respObj

        try:
            if SITE_ID_POLICY_ID != "":
                policyId, rmId = SITE_ID_POLICY_ID.split(".")
                PTIWrapper.deletePtiVsRMForPolicyId(int(policyId))
                # free RM in case it was allocated for MSD, which will not be freed in deleteFabricResources
                if rmId:
                    Util.exeRM(RM.deleteResource(int(rmId)))
        except:
            pass

        RM.deleteFabricResources(FABRIC_NAME)

        dictionaryObj["FABRIC_NAME"] = FABRIC_NAME
        PTI.executePyTemplateMethod("dhcp_utility", dictionaryObj, "deleteDHCPScopeV6")
        PTI.executePyTemplateMethod("dhcp_utility", dictionaryObj, "deleteDHCPScope")
        return respObj
    except respObjError as e:
        respObj = e.value
        return respObj
    finally:
        Wrapper.print("==========ACTION: FAB [%s]: Finish: preFabricDelete: Success = [%r]" %
                (FABRIC_NAME, respObj.isRetCodeSuccess()))
                
#preSwitchDelete - PSD#
def preSwitchDelete(dictionaryObj):
    respObj = WrappersResp.getRespObj()
    respObj.setSuccessRetCode()
    funcName = sys._getframe(0).f_code.co_name
    
    Fabric_name = ""
    try:
      forceDelete = dictionaryObj.get("force", False)
      deleteSwitch = True
      if ("notDeleteSwitch" in dictionaryObj):
          deleteSwitch = False
          Fabric_name = dictionaryObj["FABRIC_NAME"]
      else:
          Fabric_name = FABRIC_NAME
          Util.exe(actionAllow())
      Wrapper.print("==========ACTION: FAB [%s]: Start: preSwitchDelete. Serial [%s], deleteSwitch [%s]" %
                    (Fabric_name, dictionaryObj["deviceSerial"], deleteSwitch))

      sn = dictionaryObj["deviceSerial"]
      topologyDataObj = TopologyData(Util.exe(TopologyWrapper.get(Fabric_name)))
      isVPC = Util.exe(VpcWrapper.isVpc(Fabric_name, sn))
      switchRole = topologyDataObj.getSwitchRole(sn)
      hostName = Util.exe(InventoryWrapper.getHostName(sn))
      fabricSettings = Util.exe(FabricWrapper.get(Fabric_name)).getNvPairs()

      Wrapper.print("%s[%s]: Role [%s] isVPC [%s]" % (sn, hostName, switchRole, isVPC))

      dictObj = getGlobals(dictionaryObj)
      dictObj["SRNO"] = sn
      dictObj["FABRIC_NAME"] = Fabric_name
      dictObj["topologyObj"] = topologyDataObj

      FF = dictObj.get("FF", "Easy_Fabric")
      if FF == "Easy_Fabric":
          Wrapper.print("Easy Fabric template")
          
          # check whether service has been enabled
          if "border" in switchRole or "leaf" in switchRole:
              resp = L4L7ServiceWrapper.serviceNetworkAttached(sn, True)
              if resp.isRetCodeSuccess() and resp.getValue():
                    respObj = WrappersResp.getRespObj()
                    respObj.addErrorReport("SwitchRemoval", ("There are service networks being attached to this switch (or its peer switch). Please detach the service networks and deploy the changes (detach service networks) before removing this switch."), sn)
                    respObj.setFailureRetCode()
                    return respObj
              else:
                  Wrapper.print("%s(): No service network is attached, so proceed to validate the pre-deletion of switch [%s]" % (funcName, sn))                    
          if switchRole == "tor":
              if isVPC:
                  vpcPairSerialKey = Util.exe(VpcWrapper.get(VPCMetaDataType.VPC_PAIR, Fabric_name, sn))
                  pairingSns = Util.exe(ToRWrapper.getTorAssociation(vpcPairSerialKey))
                  unpairingSns = Util.exe(ToRWrapper.getMarkDeletedPairs(vpcPairSerialKey))
              else:
                  pairingSns = Util.exe(ToRWrapper.getTorAssociation(sn))
                  unpairingSns = Util.exe(ToRWrapper.getMarkDeletedPairs(sn))
              if pairingSns:
                  respObj.addErrorReport(getFabErrEntity(funcName, sn),
                      "Switch has a leaf-tor pairing. Please remove the pairing before deleting the tor switch from the fabric.", sn)
                  respObj.setFailureRetCode()
                  return respObj
              if unpairingSns:
                  respObj.addErrorReport(getFabErrEntity(funcName, sn),
                      "Please perform Recalculate and Deploy to complete Leaf-ToR unpairing before deleting the tor switch from the fabric.", sn)
                  respObj.setFailureRetCode()
                  return respObj
          elif switchRole == "leaf" and deleteSwitch:
              if isVPC:
                  vpcPairSerialKey = Util.exe(VpcWrapper.get(VPCMetaDataType.VPC_PAIR, Fabric_name, sn))
                  pairingSns = Util.exe(ToRWrapper.getTorAssociation(vpcPairSerialKey))
              else:
                  pairingSns = Util.exe(ToRWrapper.getTorAssociation(sn))
              unpairingSns = Util.exe(ToRWrapper.getMarkDeletedPairs(sn))
              if isVPC and not unpairingSns:
                  unpairingSns = Util.exe(ToRWrapper.getMarkDeletedPairs(vpcPairSerialKey))
                  if not unpairingSns:
                      vpcPeerSn = Util.exe(VpcWrapper.get(VPCMetaDataType.PEER_DEVICE_SN, Fabric_name, sn))
                      unpairingSns = Util.exe(ToRWrapper.getMarkDeletedPairs(vpcPeerSn))
              if unpairingSns:
                  respObj.addErrorReport(getFabErrEntity(funcName, sn),
                      "Please perform Recalculate and Deploy to complete Leaf-ToR unpairing before deleting the leaf switch from the fabric.", sn)
                  respObj.setFailureRetCode()
                  return respObj

              if pairingSns:
                  # Delete all tors that are associated with this leaf
                  Util.exe(cleanupLeafTorAssoc(sn, pairingSns))
                  vpcPeerProcessedList = []
                  for torSn in pairingSns:
                      if torSn in vpcPeerProcessedList:
                          continue
                      isTorVpc = Util.exe(VpcWrapper.isVpc(Fabric_name, torSn))
                      if isTorVpc:
                          torVpcPeerSn = Util.exe(VpcWrapper.get(VPCMetaDataType.PEER_DEVICE_SN, Fabric_name, torSn))
                          PTI.createOrUpdate(torSn, "SWITCH", "SWITCH", "", 10, "switch_delete_simulated", {})
                          PTI.createOrUpdate(torVpcPeerSn, "SWITCH", "SWITCH", "", 10, "switch_delete_simulated", {})
                          Wrapper.print("PSD: Unpair VPC on torSn [%s]" % torSn)
                          Util.exe(VpcWrapper.delete(torSn))

                          Wrapper.print("PSD: Delete all PTIs and resource for torVpcPeerSn [%s]" % torVpcPeerSn)
                          PTI.delete(torVpcPeerSn)
                          RM.deleteSwitchResources(torVpcPeerSn)
                          CDW.clearDeployerHistory(torVpcPeerSn)
                          InventoryWrapper.removeSwitch(Fabric_name, torVpcPeerSn)
                          vpcPeerProcessedList.append(torVpcPeerSn)

                      Wrapper.print("PSD: Delete all PTIs and resource for torSn [%s]" % torSn)
                      PTI.delete(torSn)
                      RM.deleteSwitchResources(torSn)
                      CDW.clearDeployerHistory(torSn)
                      InventoryWrapper.removeSwitch(Fabric_name, torSn)

          SSPINE_ADD_DEL_DEBUG_FLAG = fabricSettings.get("SSPINE_ADD_DEL_DEBUG_FLAG","Disable")
          if "super" in switchRole:
              Wrapper.print("Easy Fabric Super in role %s"%(switchRole))
              spinesWithSuperRole = topologyDataObj.get(TopologyInfoType.SPINES_WITH_SUPER_ROLE)
              spines = topologyDataObj.get(TopologyInfoType.SPINES)

              Wrapper.print("Easy Fabric Super role in spines count %s and normal spines count %s"%(len(spinesWithSuperRole),len(spines)))
              if len(spinesWithSuperRole) == 1 and len(spines) > 0:
                  if SSPINE_ADD_DEL_DEBUG_FLAG == "Disable":
                      respObj.addWarnReport(getFabErrEntity(funcName, sn+":Fabric without super spine role devices"),
                                            "After deletion of this device, fabric doesn't have any more super spine roles "
                                            "and performing Recalculate Config without any super spine device will generate bgp peering between spines and leafs.", sn)
                      respObj.setWarningRetCode()

      #Delete all overlays on border switches before IFCs are deleted
      if "border" == switchRole or "border spine" == switchRole or "border super spine" == switchRole:
          Util.exe(validateInterfabricDelete(sn, forceDelete))
          ptiList = Util.exe(PTI.get(sn))
          Wrapper.print("Count is %s" % (len(ptiList)))
          count = 0
          for pti in ptiList:
               if pti.getSource() == "OVERLAY":
                   PTI.deleteInstance(pti.getPolicyId())
                   count = count + 1
          if count > 0:
              Util.exe(Helper.removeItemsCSM(sn))

      if "border gateway" in switchRole:
          Util.exe(validateInterfabricDelete(sn, forceDelete))
          ifcPtiList = Util.exe(PTI.get(sn, "SWITCH", "SWITCH", "", "ifcdelete"))
          if len(ifcPtiList) == 0:
              dictObj["force"] = forceDelete
              processRespObj(respObj, PTI.executePyTemplateMethod("interface_utility", dictObj, "isMSDMemberSwitchDelAllowed"))
              if respObj.isRetCodeFailure():
                  return respObj
              else:
                  if isVPC:
                      vpcPeerSn = Util.exe(VpcWrapper.get(VPCMetaDataType.PEER_DEVICE_SN, Fabric_name, sn))
                      PTI.createOrUpdate(vpcPeerSn, "SWITCH", "SWITCH", "", 10, "ifcdelete", {})
          ptiList = Util.exe(PTI.get(sn))
          Wrapper.print("Count is %s" % (len(ptiList)))
          count = 0
          for pti in ptiList:
              if pti.getSource() == "OVERLAY":
                  PTI.deleteInstance(pti.getPolicyId())
                  count = count + 1
          if count > 0:
             Util.exe(Helper.removeItemsCSM(sn))

          if isVPC:
              Wrapper.print("PSD: started overlay deletion for VPC config")
              vpcPeerSn = Util.exe(VpcWrapper.get(VPCMetaDataType.PEER_DEVICE_SN, Fabric_name, sn))
              ptiList = Util.exe(PTI.get(vpcPeerSn))
              Wrapper.print("Count is %s" % (len(ptiList)))
              count = 0
              for pti in ptiList:
                  if pti.getSource() == "OVERLAY":
                      PTI.deleteInstance(pti.getPolicyId())
                      count = count + 1
              if count > 0:
                 Util.exe(Helper.removeItemsCSM(vpcPeerSn))
              # let the delete template do this
              # get Source Switch Id for sn
              # get count of the MS overlay IFCs for sn - snCount
              # get Source Switch Id for vpcPeerSn
              # get count of the MS overlay IFCs for vpcPeerSn --- vpcSnCount
              # remove all overlay PTIs from sn and vpcPeerSn
              # if snCount == 1 or vpcSnCount == 1:
              #     if overlays are extended over MS Overlay IFCs:
              #         Report error

      if deleteSwitch:
          # check whether service has been enabled
          if FF == "Easy_Fabric" and ("border" in switchRole or "leaf" in switchRole):
              L4L7ServiceWrapper.removeServiceSwitch(sn)
              Wrapper.print("%s(): Finished the service related config deletion for switch [%s]." % (funcName, sn))

          Util.exe(PTI.executePyTemplateMethod("Easy_Fabric_Extn_11_1", dictObj, "delFabricIntfConfig"))
          Wrapper.print("PSD: started for BGP config")
          PTI.executePyTemplateMethod("Easy_Fabric_Extn_11_1", dictObj, "bgpConfigDel")
          Wrapper.print("PSD: started for RP config")
          PTI.executePyTemplateMethod("Easy_Fabric_Extn_11_1", dictObj, "rpConfigDel")

      if isVPC:
          Wrapper.print("PSD: started for VPC config")
          vpcPeerSn = Util.exe(VpcWrapper.get(VPCMetaDataType.PEER_DEVICE_SN, Fabric_name, sn))
          PTI.createOrUpdate(sn, "SWITCH", "SWITCH", "", 10, "switch_delete_simulated", {})
          PTI.createOrUpdate(vpcPeerSn, "SWITCH", "SWITCH", "", 10, "switch_delete_simulated", {})
          #disjoinvpcParing(topologyDataObj, vpcPeerSn, False)
          Wrapper.print("PSD: Unpair VPC")
          Util.exe(VpcWrapper.delete(sn))

      Wrapper.print("PSD: Delete all PTIs of device and Convert fabric connections to hosts")
      PTI.delete(sn)
      #This is done after PTI delete to ensure Resource for
      #link subnet after freed up in the end
      RM.deleteSwitchResources(sn)
      CDW.clearDeployerHistory(sn)

      if "super" in switchRole:
          spinesWithSuperRole = topologyDataObj.get(TopologyInfoType.SPINES_WITH_SUPER_ROLE)
          spinesWithSuperRoleCnt = str(len(spinesWithSuperRole) - 1)
          FabricWrapper.update(Fabric_name, "SSPINE_COUNT", spinesWithSuperRoleCnt)
      elif "spine" in switchRole:
          spines = topologyDataObj.get(TopologyInfoType.SPINES)
          spinesRoleCnt = str(len(spines) - 1)
          FabricWrapper.update(Fabric_name, "SPINE_COUNT", spinesRoleCnt)

      #If VPC then delete both VPC pair
      if isVPC and deleteSwitch:
          InventoryWrapper.removeSwitch(Fabric_name, sn, forceDelete)
          if "border gateway" not in switchRole:
              #if check and code under it is not needed in 11.5 as not last stage of release
              #avoiding this case for taking care of vPC BGW Deletion scenarios for the B2B case
              dictionaryObj.update({"deviceSerial":vpcPeerSn})
              dictionaryObj.update({"force":forceDelete})
              preSwitchDelete(dictionaryObj)
          InventoryWrapper.removeSwitch(Fabric_name, vpcPeerSn, forceDelete)

      enableMacSec = fabricSettings.get("ENABLE_MACSEC")
      enableDCIMacSec = fabricSettings.get("ENABLE_DCI_MACSEC", "false")
      if (enableMacSec == "true" or enableDCIMacSec == "true") and deleteSwitch:
          devices = topologyDataObj.get(TopologyInfoType.SWITCHES)
          devices = filter(None, devices)
          devicesLeftCnt = (len(devices) - 2) if isVPC else (len(devices) - 1)
          if devicesLeftCnt <= 0:
              jobId = Fabric_name + "-macsec_oper_status"
              reportRespObj = ReportWrapper.getReportJob(jobId)
              if reportRespObj.isRetCodeSuccess():
                  Wrapper.print("%s(): Delete periodic report for jobId:%s" % (funcName, jobId))
                  ReportWrapper.deleteReportJob(jobId)

      if ((not isVPC) and isInbandPoapEnabled(dictObj) == "true"): 
          isLocalDhcpEnabled = True if dictObj.get("DHCP_ENABLE", "false") == "true" else False
          isNumbered = True if dictObj.get("FABRIC_INTERFACE_TYPE", "p2p") == "p2p" else False
          if isLocalDhcpEnabled and isNumbered:
            # generate all the DHCP scopes and upload to DB
            Util.exe(PTI.executePyTemplateMethod("dhcp_utility", dictObj, "dhcpScope"))     

      return respObj
    except respObjError as e:
        respObj = e.value
        return respObj
    finally:
        Wrapper.print("==========ACTION: FAB [%s]: Finish: preSwitchDelete: Serial [%s]. Success = [%r]" %
                (Fabric_name, dictionaryObj["deviceSerial"], respObj.isRetCodeSuccess()))

def configSaveInband(dictionaryObj):
    funcName = sys._getframe(0).f_code.co_name
    Wrapper.print("==========ACTION: FAB [%s]: Start: %s" % (FABRIC_NAME, funcName))
    respObj = WrappersResp.getRespObj()
    respObj.setSuccessRetCode()
    try:

        #get the whole topology from topology database
        topologyDataObj = TopologyData(Util.exe(TopologyWrapper.get(FABRIC_NAME)))
        devices = topologyDataObj.get(TopologyInfoType.SWITCHES)
        devices = filter(None, devices)

        #Need to pass bootstrapDevices dictionary to configSaveExtnInband
        dict = getGlobals(dictionaryObj)
        dict["topologyObj"] = topologyDataObj
        dict["DEVICES"] = devices
        #Wrapper.print("%s: Updated dictionary is %s" % (funcName, str(dict)))
        #Validate fabric setting change
        Util.exe(PTI.executePyTemplateMethod("fabric_utility_11_1", dict, "validateFabricSetting"))
        
        processRespObj(respObj, PTI.executePyTemplateMethod("Easy_Fabric_Extn_11_1", dict, "configSaveExtnInband"))
    except Exception as e:
        if isinstance(e, respObjError):
            Util.processRespObj(respObj, e.value)
        else:
            Util.handleException("Unexpected error process inband POAP Bootstrap switch", e, respObj)
    finally:
        Wrapper.print("==========ACTION: FAB [%s]: Finish: %s: Success = [%r]" %
                (FABRIC_NAME, funcName, respObj.isRetCodeSuccess()))
        return respObj

def configSave(dictionaryObj):
    global abstract_isis, ISIS_LEVEL, AAA_SERVER_CONF, DNS_SERVER_IP_LIST, NTP_SERVER_IP_LIST, SYSLOG_SERVER_IP_LIST, DNS_SERVER_VRF, NTP_SERVER_VRF, SYSLOG_SEV, SYSLOG_SERVER_VRF

    Wrapper.print("==========ACTION: FAB [%s]: Start: configSave" % (FABRIC_NAME))
    respObj = WrappersResp.getRespObj()
    respObj.setSuccessRetCode()
    try:
        Util.exe(actionAllow())

        dcnmUser = dictionaryObj.get("dcnmUser")
        Util.exe(FabricWrapper.update(FABRIC_NAME, "dcnmUser", dcnmUser))

        #get the whole topology from topology database
        topologyDataObj = TopologyData(Util.exe(TopologyWrapper.get(FABRIC_NAME)))

        devices = topologyDataObj.get(TopologyInfoType.SWITCHES)
        devices = filter(None, devices)

        #Valid topology
        if len(devices) == 0:
            fabricSettings = Util.exe(FabricWrapper.get(FABRIC_NAME)).getNvPairs()
            isChildFabric = Util.exe(FabricWrapper.isChidFabric(FABRIC_NAME))
            isLooseSgtEn = False
            if isChildFabric:
                msdFabricName = Util.exe(FabricWrapper.getParentFabricName(FABRIC_NAME))
                msdFabricSettings = Util.exe(FabricWrapper.get(msdFabricName)).getNvPairs()
                isLooseSgtEn = msdFabricSettings.get("ENABLE_SGT", "off") == "loose"
                sgtEnDis = msdFabricSettings.get("ENABLE_SGT", "off") == "off"
            if not isChildFabric or (isChildFabric and (isLooseSgtEn or sgtEnDis)):
                sgtEnable = (fabricSettings.get("ENABLE_SGT", "false") == "true")
                sgtRecalcRqrd = (fabricSettings.get("SGT_RECALC_STATUS", "empty") == "start")

                sgtPreprovEnable = (fabricSettings.get("SGT_PREPROVISION", "false") == "true")
                sgtPreproveRecalcRqrd = (fabricSettings.get("SGT_PREPROV_RECALC_STATUS", "empty") == "start")
                Wrapper.print("SGT Validate and Enable or Disable %s"%(sgtEnable))
                #update SG oper and recalc status

                notifyFabUpd = False
                if sgtRecalcRqrd:
                    Util.exe(TD.sgtFeatureEnableDisable(FABRIC_NAME, sgtEnable))
                    operStatus = "on" if sgtEnable else "off"
                    FabricWrapper.update(FABRIC_NAME, "SGT_OPER_STATUS", operStatus)
                    FabricWrapper.update(FABRIC_NAME, "SGT_RECALC_STATUS", "completed")
                    notifyFabUpd = True
                if sgtPreproveRecalcRqrd:
                    Util.exe(TD.sgtPreprovEnableDisable(FABRIC_NAME, sgtPreprovEnable))
                    FabricWrapper.update(FABRIC_NAME, "SGT_PREPROV_RECALC_STATUS", "completed")
                    notifyFabUpd = True
                if notifyFabUpd:
                    FabricWrapper.notifyFabricUpdate(FABRIC_NAME)
                    FabricWrapper.notifyFabricUpdateToSgm(FABRIC_NAME)


            respObj.addErrorReport(configSave.__name__, "Fabric %s cannot be deployed without any switches" % FABRIC_NAME)
            respObj.setFailureRetCode()
            return respObj

        # handle a few ISIS specific things for the DCNM 11.0 or 11.1 upgrade
        if LINK_STATE_ROUTING == 'is-is':
            # get current fabric settings
            fabricSettings = Util.exe(FabricWrapper.get(FABRIC_NAME)).getNvPairs()

            # Handle inline upgrade from 11.0 or 11.1
            cur_abstract_isis = fabricSettings['abstract_isis']
            if cur_abstract_isis == "base_isis":
                Wrapper.print("++++++++ configSave: abstract policies have 11_0/1 value, set to 11_2")
                # Even though the fabric is operating at level-1 we will set the 'abstract_isis' variable
                # to 'base_isis_level2'
                # this vatriable is not used anymore and kept only for backward compatibility
                abstract_isis = "base_isis_level2"
                Util.exe(FabricWrapper.update(FABRIC_NAME, "abstract_isis", abstract_isis))

            # check the presence of the ISIS_LEVEL fabric variable
            if not ('ISIS_LEVEL' in fabricSettings):
                Wrapper.print("++++++++ configSave: ISIS_LEVEL not found in fabric settings")
                # variable does not exist (upgrade case).. set it to 'level-1' since earlier DCNM supported level-1 only
                ISIS_LEVEL = "level-1"
                Util.exe(FabricWrapper.update(FABRIC_NAME, "ISIS_LEVEL", ISIS_LEVEL))

        # TEMP CODE PLEASE REMOVE IT AFTER NEXT DTHO ---- MANISH --- FOR INLINE UPGRADE FROM LAST DTHO
        try:
            TopDownOverlayWrapper.updateLbEntityNameInRm(fabricName)
        except:
            pass
        # TEMP CODE PLEASE REMOVE IT AFTER NEXT DTHO ---- MANISH --- FOR INLINE UPGRADE FROM LAST DTHO

        gVarDictObj = getStrGlobals()
        fabricSettings = Util.exe(FabricWrapper.get(FABRIC_NAME)).getNvPairs()
        upgradeFromVersion = fabricSettings.get("UPGRADE_FROM_VERSION", "")
        isUpgrade = (upgradeFromVersion != "")
        if isUpgrade:
            gVarDictObj.update({"topologyObj": topologyDataObj})
            gVarDictObj["upgradeFromVersion"] = upgradeFromVersion
            gVarDictObj["fabricType"] = "Switch_Fabric"
            gVarDictObj["fabricName"] = FABRIC_NAME
            FabricWrapper.sendProgress(FABRIC_NAME, "configSave", 6, "One time policies update after upgrade")
            Wrapper.print("$$$$$$$$$$$$ START PTI REGEN UPGRADE HANDLING [%s] for Fabric [%s] and upgradeFromVersion [%s] $$$$$$$$$"%
                          (datetime.datetime.time(datetime.datetime.now()), FABRIC_NAME, upgradeFromVersion))
            processRespObj(respObj, PTI.executePyTemplateMethod("fabric_upgrade_11_1", gVarDictObj, "handleUpgradeInRecalc"))
            if respObj.isRetCodeFailure():
                return respObj
            FabricErrorLogger.clear(FABRIC_NAME, Category.Fabric, ET.Fabric, FABRIC_NAME+":Upgrade")
            FabricWrapper.update(FABRIC_NAME, "UPGRADE_FROM_VERSION", "")
            FabricWrapper.sendProgress(FABRIC_NAME, "configSave", 9, "Policies update completed")
            Wrapper.print("$$$$$$$$$$$$ COMPLETED PTI REGEN UPGRADE HANDLING [%s] for Fabric [%s] and upgradeFromVersion [%s] $$$$$$$$$"%
                          (datetime.datetime.time(datetime.datetime.now()), FABRIC_NAME, upgradeFromVersion))

        gVarDictObj.update({"BRFIELD_DEBUG_FLAG": BRFIELD_DEBUG_FLAG})
        gVarDictObj.update({"topologyObj": topologyDataObj})
        gVarDictObj.update({"dcnmUser": dcnmUser})
        processRespObj(respObj, PTI.executePyTemplateMethod("fabric_upgrade_11_1", gVarDictObj, "handleUpgradeOrBrownfield"))
        if respObj.isRetCodeFailure():
            return respObj

        if LINK_STATE_ROUTING == "is-is":
            # the ISIS_LEVEL setting could have been updated in handleUpgradeOrBrownfield.. update the variable so that
            # subsequent code will get the updated value
            try:
                ISIS_LEVEL = str(Util.exe(FabricWrapper.get(FABRIC_NAME, "ISIS_LEVEL")))
                Wrapper.print("[%s]: configSave: ISIS_LEVEL set to [%s]" % (FABRIC_NAME, ISIS_LEVEL))
            finally:
                pass

        fabricSettings = Util.exe(FabricWrapper.get(FABRIC_NAME)).getNvPairs()
        if "DNS_SERVER_IP_LIST" in fabricSettings:
            DNS_SERVER_IP_LIST = str(fabricSettings["DNS_SERVER_IP_LIST"])
        if "NTP_SERVER_IP_LIST" in fabricSettings:
            NTP_SERVER_IP_LIST = str(fabricSettings["NTP_SERVER_IP_LIST"])
        if "SYSLOG_SERVER_IP_LIST" in fabricSettings:
            SYSLOG_SERVER_IP_LIST = str(fabricSettings["SYSLOG_SERVER_IP_LIST"])
        if "DNS_SERVER_VRF" in fabricSettings:
            DNS_SERVER_VRF = str(fabricSettings["DNS_SERVER_VRF"])
        if "NTP_SERVER_VRF" in fabricSettings:
            NTP_SERVER_VRF = str(fabricSettings["NTP_SERVER_VRF"])
        if "SYSLOG_SEV" in fabricSettings:
            SYSLOG_SEV = str(fabricSettings["SYSLOG_SEV"])
        if "SYSLOG_SERVER_VRF" in fabricSettings:
            SYSLOG_SERVER_VRF = str(fabricSettings["SYSLOG_SERVER_VRF"])
                 
        #Validate fabric setting change
        dictObj = getStrGlobals()
        dictObj.update({"DEVICES": devices})
        dictObj.update({"topologyObj": topologyDataObj})
        Util.exe(PTI.executePyTemplateMethod("fabric_utility_11_1", dictObj, "validateFabricSetting"))

        dict = getGlobals()
        dict["topologyObj"] = topologyDataObj
        processRespObj(respObj, PTI.executePyTemplateMethod("Easy_Fabric_Extn_11_1", dict, "configSaveExtn"))
        Util.exe(Util.topDownRmTrackingRqrd(FABRIC_NAME, devices))
        Wrapper.print("configSave: after calling configSaveExtn")
        return respObj
    except respObjError as e:
        respObj = e.value
        return respObj
    finally:
        Wrapper.print("==========ACTION: FAB [%s]: Finish: configSave: Success = [%r]" %
                (FABRIC_NAME, respObj.isRetCodeSuccess()))

def processRespObj(respObj, newResp):
    Wrapper.print("processRespObj: respObj isSuccess [%r] newResp isSuccess [%r]" % (respObj.isRetCodeSuccess(), newResp.isRetCodeSuccess()))
    errs = newResp.getErrorList()
    if (errs != None):
        if not respObj.isRetCodeFailure():
            # since there is a valid error list.. we assume the retcode is a non-success error code
            respObj.setRetCode(newResp.getRetCode())
        list = respObj.getErrorList()
        if (list != None):
            Wrapper.print("processRespObj: Found %d error entries. Adding %d more" % (len(list), len(errs)))
        else:
            Wrapper.print("processRespObj: Adding %d entries" % len(errs))
            list = []

        for err in errs:
            list.append(err)
        respObj.setErrorList(list)
    if newResp.isResolve() == True:
        respObj.setResolve(newResp.isResolve())
        respObj.setResolveId(newResp.getResolveId())
        resolvePayload = {}
        respObj.setResolvePayload(newResp.getResolvePayload())
        
    Wrapper.print("processRespObj: After respObj isSuccess [%r]" % (respObj.isRetCodeSuccess()))

def getFormattedSwitchName(serialNum):
    formattedStr = serialNum
    hostName = InventoryWrapper.getHostNameString(serialNum)
    if hostName:
        formattedStr += ("/" + hostName)
    return formattedStr

def cleanupLeafTorAssoc(leafSn, pairingSns):
    try:
        funcName = sys._getframe(0).f_code.co_name
        Wrapper.print("%s(): leafSn:[%s] pairingSns:%s" % (funcName, leafSn, pairingSns))

        vpcPeerProcessedList = []
        for torSn in pairingSns:
            if torSn in vpcPeerProcessedList:
                continue
            leafVpcPeerSn = torVpcPeerSn = torVpcPairSerialKey = ""
            isTorVpc = Util.exe(VpcWrapper.isVpc(FABRIC_NAME, torSn))
            if isTorVpc:
                torVpcPairSerialKey = Util.exe(VpcWrapper.get(VPCMetaDataType.VPC_PAIR, FABRIC_NAME, torSn))
                serials = torVpcPairSerialKey.split(Helper.DELIMITER)
                torVpcPeerSn = serials[0] if serials[1] == torSn else serials[1]
                leafSns = Util.exe(ToRWrapper.getTorAssociation(torVpcPairSerialKey))
                vpcPeerProcessedList.append(torVpcPeerSn)
            else:
                leafSns = Util.exe(ToRWrapper.getTorAssociation(torSn))

            if not leafSns:
                Wrapper.print("%s(): No leaf-tor pairing found for the tor" % torSn)
                continue

            if len(leafSns) == 2:
                leafVpcPeerSn = Util.exe(VpcWrapper.get(VPCMetaDataType.PEER_DEVICE_SN, FABRIC_NAME, leafSn))

            Wrapper.print("%s(): Calling deleteLeafToR() leafSn %s leafVpcPeerSn %s torSn %s torVpcPeerSn %s" %
                          (funcName, leafSn, leafVpcPeerSn, torSn, torVpcPeerSn))
            Util.exe(ToRWrapper.deleteLeafToR(leafSn, leafVpcPeerSn, torSn, torVpcPeerSn))

        respObj = WrappersResp.getRespObj()
        respObj.setSuccessRetCode()
        return respObj

    except respObjError as e:
        return e.value

def validateInterfabricDelete(serial_number, forceDelete):
    Wrapper.print("==========ACTION: Serial Number [%s] : Start: validateInterfabricDelete with forceDelete [%s]" % (serial_number, forceDelete))
    try:
        respObj = WrappersResp.getRespObj()
        respObj.setSuccessRetCode()

        wResp = InterfabricConnectionWrapper.listInterfabrics(serial_number)
        if wResp.isRetCodeSuccess():
            Wrapper.print("validateInterfabricDelete: Incoming IFC links to: [%s]" % (serial_number))
            interfabric_list = wResp.getValue()
        else:
            Wrapper.print("validateInterfabricDelete: Error hit in get Incoming IFC links for [%s]: " %(serial_number))
            return wResp
        
        if forceDelete:
            for ifc in interfabric_list:
                Wrapper.print("validateInterfabricDelete: IFC links for [%s]: ifc [%s]" %(serial_number, ifc))
                srcSn = ifc["source_switch_sn"]
                dstSn = ifc["dest_switch_sn"]
                Util.exe(Util.deleteExtensions(srcSn, dstSn))

        for ifc in interfabric_list:
            if ifc["extension_type"] == "VRF_LITE" or ifc["extension_type"] == "VXLAN_MPLS_OVERLAY":
                Wrapper.print("validateInterfabricDelete: Processing IFC ID %s" %(ifc["interfabricId"]))
                extension_id = int(ifc["interfabricId"])
                ifc_extension_exists = Util.exe(InterfabricConnectionWrapper.checkIFCExtensions(extension_id))

                if ifc_extension_exists:
                    srcSwitchStr = getFormattedSwitchName(ifc["source_switch_sn"])
                    destSwitchStr = getFormattedSwitchName(ifc["dest_switch_sn"])

                    errorMsg = ("Failed to delete switch. Overlays are extended for interfabric link [%s] [%s]<-->[%s] [%s]"
                                %(srcSwitchStr, ifc["source_if_name"], destSwitchStr, ifc["dest_if_name"]))
                    respObj.addErrorReport(("InterFabricLink"), errorMsg, serial_number)
                    respObj.setFailureRetCode()
                    return respObj
        return respObj
    except respObjError as e:
        respObj = e.value
        return respObj

    finally:
        Wrapper.print("==========ACTION: SN [%s]: Finish: validateInterfabricDelete: Success = [%r]" % \
                (serial_number, respObj.isRetCodeSuccess()))
##
#
